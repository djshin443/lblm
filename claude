import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import cv2
import numpy as np
import pyautogui
import threading
import time
import datetime
import os
import platform
import gc
from PIL import Image, ImageTk, ImageFont, ImageDraw
import sys
from pynput import mouse
import screeninfo
import textwrap
from collections import deque
from queue import Queue, Empty


class ScreenRecorderApp:
    def __init__(self, root):
        self.root = root
        self.root.title("화면 녹화 및 캡처 도구")
        self.root.geometry("600x400")
        self.root.resizable(True, True)

        # 스타일 설정
        self.style = ttk.Style()
        self.style.configure('TButton', font=('Arial', 10))
        self.style.configure('TLabel', font=('Arial', 10))

        # 변수 초기화
        self.recording = False
        self.capturing = False
        self.selected_area = None
        self.frame_rate = 30.0
        self.output_file = None
        self.video_writer = None
        self.video_thread = None
        self.video_format = tk.StringVar(value="mp4")  # 기본값 MP4

        # 마우스 클릭 포인트 관련 변수
        self.click_points = deque(maxlen=100)  # 최대 100개 클릭 포인트 저장
        self.mouse_listener = None
        self.show_click_points = tk.BooleanVar(value=True)
        self.click_point_duration = 1.0  # 포인트 표시 지속 시간(초)

        # 마우스 드래그 선 그리기 관련 변수
        self.show_mouse_trail = tk.BooleanVar(value=False)
        self.mouse_trail_points = deque(maxlen=50)  # 최대 50개 트레일 저장
        self.is_mouse_dragging = False
        self.current_trail = []
        self.min_trail_point_distance = 5  # 최소 트레일 포인트 간격 (픽셀)

        # 마우스 커서 표시 관련 변수
        self.show_cursor = tk.BooleanVar(value=True)  # 기본적으로 커서 표시
        self.cursor_size = 20  # 커서 크기
        self.last_cursor_pos = (0, 0)  # 마지막 커서 위치

        # 텍스트 오버레이 변수
        self.overlay_text = ""
        self.show_overlay_text = tk.BooleanVar(value=False)
        self.text_position = (20, 50)  # 기본 위치 (좌상단에서 조금 아래로)
        self.text_color = (255, 255, 255)  # 흰색 텍스트
        self.text_size = 30  # 폰트 크기 증가
        self.text_thickness = 2  # 텍스트 두께
        self.text_padding = 15  # 텍스트 주변 여백
        self.max_text_width_ratio = 0.8  # 화면 너비의 80%를 최대 텍스트 너비로 설정

        # 텍스트 오버레이 캐싱 변수
        self.text_overlay_cache = None
        self.last_overlay_text = ""
        self.last_text_position = (0, 0)

        # 한글 표시를 위한 PIL 이미지 사용 여부
        self.use_pil_for_text = True
        self.pil_font = None  # 나중에 초기화

        # 모니터 정보
        self.monitors = screeninfo.get_monitors()
        self.selected_monitor = None

        # 성능 모니터링 변수
        self.frame_times = deque(maxlen=100)  # 최근 100개 프레임의 처리 시간 저장
        self.debug_mode = False  # 디버그 모드 플래그
        
        # 프레임 버퍼 및 관련 변수
        self.frame_buffer = Queue(maxsize=30)  # 최대 30개 프레임 버퍼링
        self.capture_thread = None
        self.process_thread = None

        # 메인 프레임
        main_frame = ttk.Frame(root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 위젯 생성
        self.create_widgets(main_frame)

        # 종료 시 정리
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        # 버튼 초기 상태 설정
        self.update_record_button_state()

        # 한글 폰트 초기화 시도
        self.init_korean_font()

    def init_korean_font(self):
        """한글 표시를 위한 PIL 폰트 초기화"""
        try:
            # Windows의 경우 맑은 고딕 폰트 사용
            if os.name == 'nt':
                font_path = os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Fonts', 'malgun.ttf')
                if os.path.exists(font_path):
                    self.pil_font = ImageFont.truetype(font_path, self.text_size)
                    return

            # macOS의 경우 애플고딕 폰트 사용
            if os.name == 'posix' and os.path.exists('/System/Library/Fonts'):
                font_path = '/System/Library/Fonts/AppleSDGothicNeo.ttc'
                if os.path.exists(font_path):
                    self.pil_font = ImageFont.truetype(font_path, self.text_size)
                    return

            # 기본 폰트 사용
            self.pil_font = ImageFont.load_default()

        except Exception as e:
            print(f"한글 폰트 초기화 오류: {e}")
            self.use_pil_for_text = False
            self.pil_font = None

    def distance(self, p1, p2):
        """두 점 사이의 거리 계산"""
        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5

    def wrap_text(self, text, font, max_width):
        """텍스트를 주어진 너비에 맞게 줄바꿈하는 함수"""
        if not text:
            return []

        # 임시 이미지와 드로우 객체 생성
        temp_img = Image.new('RGB', (1, 1))
        temp_draw = ImageDraw.Draw(temp_img)

        lines = []
        paragraphs = text.split('\n')  # 원래 줄바꿈 유지

        for paragraph in paragraphs:
            if not paragraph:
                lines.append("")
                continue

            words = paragraph.split()
            if not words:
                lines.append("")
                continue

            current_line = []
            current_width = 0

            for word in words:
                # 띄어쓰기를 포함한 단어
                word_with_space = word if not current_line else " " + word
                word_width = temp_draw.textlength(word_with_space, font=font)

                if current_width + word_width <= max_width or not current_line:
                    current_line.append(word_with_space.strip())
                    current_width += word_width
                else:
                    lines.append(" ".join(current_line))
                    current_line = [word]
                    current_width = temp_draw.textlength(word, font=font)

            if current_line:
                lines.append(" ".join(current_line))

        return lines

    def create_widgets(self, parent):
        # 상단 프레임 (녹화 설정)
        top_frame = ttk.LabelFrame(parent, text="녹화 설정", padding="10")
        top_frame.pack(fill=tk.X, padx=5, pady=5)

        # 출력 파일 선택
        file_frame = ttk.Frame(top_frame)
        file_frame.pack(fill=tk.X, pady=5)

        ttk.Label(file_frame, text="저장 위치:").pack(side=tk.LEFT, padx=5)
        self.file_path_var = tk.StringVar()
        self.file_path_var.trace("w", self.update_record_button_state)  # 파일 경로 변경 시 버튼 상태 업데이트
        self.file_path_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, width=40)
        self.file_path_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.browse_button = ttk.Button(file_frame, text="찾아보기", command=self.browse_output_file)
        self.browse_button.pack(side=tk.LEFT, padx=5)

        # 파일 형식 선택
        format_frame = ttk.Frame(top_frame)
        format_frame.pack(fill=tk.X, pady=5)

        ttk.Label(format_frame, text="파일 형식:").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(format_frame, text="MP4", variable=self.video_format, value="mp4").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(format_frame, text="AVI", variable=self.video_format, value="avi").pack(side=tk.LEFT, padx=5)

        # 녹화 옵션
        options_frame = ttk.Frame(top_frame)
        options_frame.pack(fill=tk.X, pady=5)

        ttk.Label(options_frame, text="프레임 레이트:").pack(side=tk.LEFT, padx=5)
        self.frame_rate_var = tk.StringVar(value="30")
        frame_rate_entry = ttk.Entry(options_frame, textvariable=self.frame_rate_var, width=5)
        frame_rate_entry.pack(side=tk.LEFT, padx=5)

        # 마우스 클릭 포인트 및 커서 표시 옵션
        mouse_options_frame = ttk.Frame(top_frame)
        mouse_options_frame.pack(fill=tk.X, pady=5)

        ttk.Checkbutton(mouse_options_frame, text="마우스 클릭 포인트 표시", variable=self.show_click_points).pack(side=tk.LEFT,
                                                                                                         padx=5)
        ttk.Checkbutton(mouse_options_frame, text="마우스 커서 표시", variable=self.show_cursor).pack(side=tk.LEFT, padx=20)
        ttk.Checkbutton(mouse_options_frame, text="마우스 드래그 선 표시", variable=self.show_mouse_trail).pack(side=tk.LEFT,
                                                                                                       padx=20)

        # 텍스트 오버레이 옵션
        text_overlay_frame = ttk.Frame(top_frame)
        text_overlay_frame.pack(fill=tk.X, pady=5)

        ttk.Checkbutton(text_overlay_frame, text="텍스트 표시", variable=self.show_overlay_text).pack(side=tk.LEFT, padx=5)
        ttk.Button(text_overlay_frame, text="텍스트 설정", command=self.set_overlay_text).pack(side=tk.LEFT, padx=5)

        # 현재 텍스트 표시
        self.overlay_text_var = tk.StringVar(value="텍스트 없음")
        ttk.Label(text_overlay_frame, textvariable=self.overlay_text_var, width=30, anchor=tk.W).pack(side=tk.LEFT,
                                                                                                      padx=5)

        # 녹화 컨트롤 프레임
        control_frame = ttk.Frame(parent)
        control_frame.pack(fill=tk.X, padx=5, pady=5)

        # 화면 캡처 영역 선택 버튼
        area_frame = ttk.Frame(control_frame)
        area_frame.pack(fill=tk.X, pady=5)

        ttk.Button(area_frame, text="화면 영역 선택", command=self.select_screen_area).pack(side=tk.LEFT, padx=5)
        ttk.Button(area_frame, text="모니터 선택", command=self.select_monitor).pack(side=tk.LEFT, padx=5)
        self.area_info_var = tk.StringVar(value="전체 화면")
        ttk.Label(area_frame, textvariable=self.area_info_var).pack(side=tk.LEFT, padx=5)

        # 디버그 모드 토글 추가
        debug_frame = ttk.Frame(control_frame)
        debug_frame.pack(fill=tk.X, pady=5)
        ttk.Checkbutton(debug_frame, text="디버그 모드", variable=tk.BooleanVar(value=self.debug_mode), 
                        command=self.toggle_debug_mode).pack(side=tk.LEFT, padx=5)

        # 녹화 및 캡처 버튼
        buttons_frame = ttk.Frame(control_frame)
        buttons_frame.pack(fill=tk.X, pady=10)

        self.record_button = ttk.Button(buttons_frame, text="녹화 시작", command=self.toggle_recording)
        self.record_button.pack(side=tk.LEFT, padx=5)

        ttk.Button(buttons_frame, text="스크린샷 캡처", command=self.capture_screenshot).pack(side=tk.LEFT, padx=5)

        # 상태 표시줄
        self.status_var = tk.StringVar(value="준비")
        ttk.Label(parent, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W).pack(fill=tk.X, padx=5, pady=5)

    def toggle_debug_mode(self):
        """디버그 모드 토글"""
        self.debug_mode = not self.debug_mode
        if self.debug_mode:
            print("디버그 모드 활성화")
        else:
            print("디버그 모드 비활성화")

    def update_record_button_state(self, *args):
        """파일 경로 입력 여부에 따라 녹화 버튼 상태 업데이트"""
        if self.file_path_var.get().strip():
            self.record_button.config(state=tk.NORMAL)
        else:
            self.record_button.config(state=tk.DISABLED)

    def set_overlay_text(self):
        """텍스트 오버레이 설정 대화상자"""
        if self.recording:
            messagebox.showinfo("알림", "녹화 중에는 텍스트를 변경할 수 없습니다.")
            return

        # 텍스트 입력 대화창
        text = simpledialog.askstring("텍스트 입력", "화면에 표시할 텍스트를 입력하세요:",
                                      initialvalue=self.overlay_text)

        if text is not None:  # 취소를 누르지 않았으면
            self.overlay_text = text
            if text:
                self.overlay_text_var.set(f"텍스트: {text[:20]}{'...' if len(text) > 20 else ''}")
                self.show_overlay_text.set(True)
                # 텍스트가 변경되었으므로 캐시 초기화
                self.text_overlay_cache = None
            else:
                self.overlay_text_var.set("텍스트 없음")
                self.show_overlay_text.set(False)
                self.text_overlay_cache = None

    def browse_output_file(self):
        # 현재 선택된 파일 형식에 따라 확장자 결정
        file_ext = "." + self.video_format.get()

        file_path = filedialog.asksaveasfilename(
            defaultextension=file_ext,
            filetypes=[
                ("MP4 files", "*.mp4"),
                ("AVI files", "*.avi"),
                ("All files", "*.*")
            ]
        )
        if file_path:
            self.file_path_var.set(file_path)

    def select_monitor(self):
        """모니터 선택 대화상자"""
        # 모니터 선택 창
        monitor_window = tk.Toplevel(self.root)
        monitor_window.title("모니터 선택")
        monitor_window.geometry("400x300")
        monitor_window.transient(self.root)
        monitor_window.grab_set()

        ttk.Label(monitor_window, text="녹화할 모니터를 선택하세요:", font=('Arial', 12)).pack(pady=10)

        # 모니터 목록
        listbox = tk.Listbox(monitor_window, selectmode=tk.SINGLE, font=('Arial', 10))
        listbox.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        for i, monitor in enumerate(self.monitors):
            listbox.insert(tk.END, f"모니터 {i + 1}: {monitor.width}x{monitor.height} (위치: {monitor.x}, {monitor.y})")

        def on_select():
            selection = listbox.curselection()
            if selection:
                self.selected_monitor = self.monitors[selection[0]]
                self.selected_area = (self.selected_monitor.x, self.selected_monitor.y,
                                      self.selected_monitor.width, self.selected_monitor.height)
                self.area_info_var.set(f"모니터 {selection[0] + 1} 선택됨")
                monitor_window.destroy()
            else:
                messagebox.showwarning("경고", "모니터를 선택해주세요.")

        ttk.Button(monitor_window, text="선택", command=on_select).pack(pady=10)

    def select_screen_area(self):
        # 현재 창 최소화
        self.root.iconify()
        time.sleep(0.5)  # 창이 최소화될 시간 부여

        # 새 창 생성 (전체 화면)
        selection_window = tk.Toplevel()
        selection_window.attributes('-fullscreen', True)
        selection_window.attributes('-alpha', 0.3)  # 반투명 화면

        # 선택 영역 변수
        start_x = start_y = end_x = end_y = 0
        selection_rect = None

        # 마우스 이벤트 처리
        def on_mouse_down(event):
            nonlocal start_x, start_y, selection_rect
            start_x, start_y = event.x, event.y
            if selection_rect:
                selection_window.canvas.delete(selection_rect)
            selection_rect = selection_window.canvas.create_rectangle(
                start_x, start_y, start_x, start_y,
                outline="red", width=2
            )

        def on_mouse_move(event):
            nonlocal selection_rect, start_x, start_y
            if selection_rect:
                end_x, end_y = event.x, event.y
                selection_window.canvas.coords(selection_rect, start_x, start_y, end_x, end_y)

        def on_mouse_up(event):
            nonlocal start_x, start_y, end_x, end_y
            end_x, end_y = event.x, event.y

            # 좌표 정규화 (시작점이 항상 왼쪽 위)
            if start_x > end_x:
                start_x, end_x = end_x, start_x
            if start_y > end_y:
                start_y, end_y = end_y, start_y

            # 창 닫기
            selection_window.destroy()

            # 선택된 영역 저장
            width = end_x - start_x
            height = end_y - start_y

            # 너무 작은 영역은 무시
            if width < 10 or height < 10:
                messagebox.showwarning("경고", "선택한 영역이 너무 작습니다. 다시 선택해주세요.")
                self.root.deiconify()
                return

            self.selected_area = (start_x, start_y, width, height)
            self.area_info_var.set(f"선택 영역: {start_x}, {start_y}, {width} x {height}")

            # 메인 창 복원
            self.root.deiconify()

        # 취소 처리
        def on_cancel(event=None):
            selection_window.destroy()
            self.root.deiconify()

        # 캔버스 생성
        selection_window.canvas = tk.Canvas(selection_window, cursor="cross")
        selection_window.canvas.pack(fill=tk.BOTH, expand=True)

        # 이벤트 바인딩
        selection_window.canvas.bind("<ButtonPress-1>", on_mouse_down)
        selection_window.canvas.bind("<B1-Motion>", on_mouse_move)
        selection_window.canvas.bind("<ButtonRelease-1>", on_mouse_up)
        selection_window.bind("<Escape>", on_cancel)

        # 안내 텍스트
        selection_window.canvas.create_text(
            selection_window.winfo_screenwidth() // 2,
            selection_window.winfo_screenheight() // 2,
            text="마우스로 드래그하여 화면 영역을 선택하세요. (ESC: 취소)",
            fill="white", font=("Arial", 16)
        )

    def toggle_recording(self):
        if not self.recording:
            self.start_recording()
        else:
            self.stop_recording()

    def start_recording(self):
        # 파일 경로 확인
        output_file = self.file_path_var.get().strip()
        if not output_file:
            messagebox.showwarning("경고", "저장 경로를 지정해주세요.")
            return

        # 파일 형식 가져오기
        file_format = self.video_format.get()

        # 확장자 확인 및 수정
        if not (output_file.lower().endswith(f".{file_format}")):
            output_file = f"{output_file}.{file_format}"
            self.file_path_var.set(output_file)

        # 이미 파일이 존재하는지 확인
        if os.path.exists(output_file):
            if not messagebox.askyesno("확인", f"파일 '{output_file}'이(가) 이미 존재합니다. 덮어쓰시겠습니까?"):
                return

        # 녹화 설정
        try:
            self.frame_rate = float(self.frame_rate_var.get())
            if self.frame_rate <= 0:
                self.frame_rate = 30.0
                self.frame_rate_var.set("30")
        except ValueError:
            self.frame_rate = 30.0
            self.frame_rate_var.set("30")

        # 화면 크기 결정
        if self.selected_area:
            x, y, width, height = self.selected_area
        else:
            # 전체 화면
            width, height = pyautogui.size()
            x, y = 0, 0

        # 비디오 형식에 따른 코덱 선택 (최적화)
        if file_format == 'mp4':
            # 플랫폼별 최적 코덱 선택
            if platform.system() == 'Windows':
                fourcc_code = 'H264'  # Windows에서 H.264 사용
            else:
                fourcc_code = 'avc1'  # macOS/Linux에서 H.264 사용
        else:
            fourcc_code = 'XVID'  # AVI는 XVID 코덱 사용

        # 비디오 라이터 설정 - 실시간 저장을 위해 직접 파일에 쓰기
        fourcc = cv2.VideoWriter_fourcc(*fourcc_code)
        self.video_writer = cv2.VideoWriter(output_file, fourcc, self.frame_rate, (width, height))

        if not self.video_writer.isOpened():
            messagebox.showerror("오류", f"비디오 파일을 생성할 수 없습니다. 형식: {file_format}, 코덱: {fourcc_code}")
            return

        # 파일 디렉토리에 대한 쓰기 권한 확인
        try:
            output_dir = os.path.dirname(output_file)
            if output_dir and not os.access(output_dir, os.W_OK):
                messagebox.showerror("오류", f"폴더에 쓰기 권한이 없습니다: {output_dir}")
                return
        except Exception as e:
            print(f"디렉토리 권한 확인 오류: {e}")

        # 프레임 버퍼 초기화
        while not self.frame_buffer.empty():
            try:
                self.frame_buffer.get_nowait()
            except Empty:
                break

        # 녹화 시작
        self.recording = True
        self.record_button.config(text="녹화 중지")
        self.status_var.set("녹화 중...")

        # 파일 경로 및 형식 변경 비활성화
        self.file_path_entry.config(state='disabled')
        self.browse_button.config(state='disabled')

        # 클릭 포인트 초기화
        self.click_points.clear()
        self.mouse_trail_points.clear()
        self.current_trail = []

        # 마우스 리스너 시작
        if self.show_click_points.get() or self.show_cursor.get() or self.show_mouse_trail.get():
            self.start_mouse_listener()

        # 캡처 및 처리 스레드 시작
        self.start_recording_threads(x, y, width, height)

    def start_recording_threads(self, x, y, width, height):
        """녹화를 위한 캡처 및 처리 스레드 시작"""
        
        # 녹화 스레드 관리
        self.video_thread = threading.Thread(target=self._recording_manager_thread, args=(x, y, width, height))
        self.video_thread.daemon = True
        self.video_thread.start()

    def _recording_manager_thread(self, x, y, width, height):
        """녹화 관리 스레드 - 캡처와 처리 스레드를 관리"""
        try:
            # 캡처 스레드 시작
            self.capture_thread = threading.Thread(
                target=self._frame_capture_thread, 
                args=(x, y, width, height)
            )
            self.capture_thread.daemon = True
            self.capture_thread.start()
            
            # 처리 스레드 시작
            self.process_thread = threading.Thread(
                target=self._frame_processing_thread,
                args=(x, y, width, height)
            )
            self.process_thread.daemon = True
            self.process_thread.start()
            
            # 녹화 시간 및 UI 업데이트
            start_time = time.time()
            while self.recording:
                # 녹화 시간 업데이트
                elapsed_time = time.time() - start_time
                recording_time = int(elapsed_time)
                
                # 평균 FPS 계산 (디버그 모드)
                if self.debug_mode and self.frame_times:
                    avg_frame_time = sum(self.frame_times) / len(self.frame_times)
                    avg_fps = 1.0 / avg_frame_time if avg_frame_time > 0 else 0
                    buffer_size = self.frame_buffer.qsize()
                    
                    status_text = (f"녹화 중... {recording_time // 60:02d}:{recording_time % 60:02d} "
                                 f"(FPS: {avg_fps:.2f}, 버퍼: {buffer_size})")
                else:
                    status_text = f"녹화 중... {recording_time // 60:02d}:{recording_time % 60:02d}"
                
                self.root.after_idle(lambda t=status_text: self.status_var.set(t))
                time.sleep(0.1)  # UI 업데이트 주기
                
            # 스레드 종료 대기
            if self.capture_thread:
                self.capture_thread.join(timeout=2.0)
            if self.process_thread:
                self.process_thread.join(timeout=2.0)
                
        except Exception as e:
            print(f"녹화 관리 스레드 오류: {e}")
            self.recording = False

    def _frame_capture_thread(self, x, y, width, height):
        """프레임 캡처 스레드 - 화면을 캡처하여 버퍼에 추가"""
        try:
            frame_interval = 1.0 / self.frame_rate
            last_capture_time = time.time()
            
            while self.recording:
                current_time = time.time()
                elapsed = current_time - last_capture_time
                
                # 프레임 레이트에 맞게 캡처
                if elapsed >= frame_interval:
                    # 화면 캡처
                    frame = self.capture_screen(x, y, width, height)
                    
                    # 버퍼가 가득 차지 않았으면 프레임 추가
                    if not self.frame_buffer.full():
                        self.frame_buffer.put((frame, current_time))
                    else:
                        # 버퍼가 가득 찼을 때 디버그 모드에서 경고
                        if self.debug_mode:
                            print("경고: 프레임 버퍼가 가득 찼습니다.")
                    
                    last_capture_time = current_time
                else:
                    # 다음 캡처 시간까지 짧게 대기
                    sleep_time = max(0, frame_interval - elapsed)
                    time.sleep(min(sleep_time, 0.001))
        
        except Exception as e:
            print(f"프레임 캡처 스레드 오류: {e}")
            self.recording = False

    def _frame_processing_thread(self, x, y, width, height):
        """프레임 처리 스레드 - 버퍼에서 프레임을 가져와 처리하고 비디오에 저장"""
        try:
            while self.recording or not self.frame_buffer.empty():
                # 버퍼에서 프레임 가져오기
                try:
                    if not self.frame_buffer.empty():
                        frame, frame_time = self.frame_buffer.get(timeout=0.1)
                        process_start_time = time.time()
                        
                        # 프레임 처리
                        processed_frame = self.process_frame(frame, x, y, width, height)
                        
                        # 비디오에 프레임 추가
                        if self.video_writer and self.video_writer.isOpened():
                            self.video_writer.write(processed_frame)
                        
                        # 처리 시간 측정
                        process_time = time.time() - process_start_time
                        self.frame_times.append(process_time)
                        
                        if self.debug_mode:
                            print(f"프레임 처리 시간: {process_time:.4f}s")
                    else:
                        # 버퍼가 비었을 때는 잠시 대기
                        time.sleep(0.01)
                
                except Empty:
                    # 버퍼가 비었을 때는 잠시 대기
                    time.sleep(0.01)
                except Exception as e:
                    print(f"프레임 처리 오류: {e}")
        
        except Exception as e:
            print(f"프레임 처리 스레드 오류: {e}")
            self.recording = False

    def capture_screen(self, x, y, width, height):
        """화면 캡처 함수"""
        screenshot = pyautogui.screenshot(region=(x, y, width, height))
        frame = np.array(screenshot)
        return cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

    def process_frame(self, frame, x_offset, y_offset, width, height):
        """프레임 처리 함수 - 마우스 이벤트, 오버레이 등 처리"""
        # 마우스 드래그 선 표시
        if self.show_mouse_trail.get():
            frame = self.draw_mouse_trail(frame, x_offset, y_offset, width, height)
        
        # 마우스 클릭 포인트 표시
        if self.show_click_points.get():
            frame = self.draw_click_points(frame, x_offset, y_offset)
        
        # 마우스 커서 표시
        if self.show_cursor.get():
            frame = self.draw_cursor(frame, x_offset, y_offset, width, height)
        
        # 텍스트 오버레이 표시
        if self.show_overlay_text.get() and self.overlay_text:
            frame = self.draw_text_overlay(frame, width, height)
        
        return frame

    def draw_mouse_trail(self, frame, x_offset, y_offset, width, height):
        """마우스 드래그 선 그리기"""
        # 현재 드래그 중인 선 그리기
        if self.is_mouse_dragging and len(self.current_trail) > 1:
            for i in range(len(self.current_trail) - 1):
                start_point = self.current_trail[i]
                end_point = self.current_trail[i + 1]

                # 선택된 영역이 있는 경우 좌표 조정
                start_x, start_y = start_point[0] - x_offset, start_point[1] - y_offset
                end_x, end_y = end_point[0] - x_offset, end_point[1] - y_offset

                # 화면 영역 내부에 있는 경우만 그리기
                if (0 <= start_x < width and 0 <= start_y < height and
                        0 <= end_x < width and 0 <= end_y < height):
                    cv2.line(frame, (start_x, start_y), (end_x, end_y), (0, 0, 255), 2)

        # 이전에 그린 선들도 표시 (페이드 아웃 효과)
        current_time = time.time()
        for points, trail_time in self.mouse_trail_points:
            fade_factor = max(0, 1 - (current_time - trail_time) / 2.0)  # 2초 동안 페이드 아웃
            if fade_factor > 0:
                for i in range(len(points) - 1):
                    start_point = points[i]
                    end_point = points[i + 1]

                    start_x, start_y = start_point[0] - x_offset, start_point[1] - y_offset
                    end_x, end_y = end_point[0] - x_offset, end_point[1] - y_offset

                    if (0 <= start_x < width and 0 <= start_y < height and
                            0 <= end_x < width and 0 <= end_y < height):
                        color = (0, 0, int(255 * fade_factor))
                        cv2.line(frame, (start_x, start_y), (end_x, end_y), color, 2)
        
        return frame

    def draw_click_points(self, frame, x_offset, y_offset):
        """마우스 클릭 포인트 그리기"""
        current_time = time.time()
        
        # 클릭 포인트 그리기
        for click_x, click_y, click_time in self.click_points:
            # 선택된 영역이 있는 경우 좌표 조정
            relative_x = click_x - x_offset
            relative_y = click_y - y_offset
            
            # 화면 영역 내부에 있는 클릭만 표시
            if 0 <= relative_x < frame.shape[1] and 0 <= relative_y < frame.shape[0]:
                # 클릭 후 지속 시간 이내인 경우만 표시
                if current_time - click_time <= self.click_point_duration:
                    # 시간에 따라 크기와 투명도 조절
                    time_ratio = 1 - (current_time - click_time) / self.click_point_duration
                    radius = int(10 * time_ratio) + 5
                    cv2.circle(frame, (relative_x, relative_y), radius, (0, 0, 255), -1)
        
        return frame

    def draw_cursor(self, frame, x_offset, y_offset, width, height):
        """마우스 커서 그리기"""
        cursor_x, cursor_y = self.last_cursor_pos
        
        # 선택된 영역이 있는 경우 좌표 조정
        relative_x = cursor_x - x_offset
        relative_y = cursor_y - y_offset
        
        # 화면 영역 내부에 있는 커서만 표시
        if 0 <= relative_x < width and 0 <= relative_y < height:
            # 간단한 십자 모양 커서 그리기
            cursor_size = self.cursor_size
            cv2.line(frame, (relative_x - cursor_size // 2, relative_y),
                     (relative_x + cursor_size // 2, relative_y), (0, 255, 0), 2)
            cv2.line(frame, (relative_x, relative_y - cursor_size // 2),
                     (relative_x, relative_y + cursor_size // 2), (0, 255, 0), 2)
        
        return frame

    def draw_text_overlay(self, frame, width, height):
        """텍스트 오버레이 그리기 (캐싱 적용)"""
        # 텍스트나 위치가 변경된 경우에만 다시 렌더링
        if (self.overlay_text != self.last_overlay_text or 
            self.text_position != self.last_text_position or 
            self.text_overlay_cache is None):
            
            # PIL로 텍스트 렌더링
            if self.use_pil_for_text and self.pil_font:
                try:
                    # OpenCV 프레임을 PIL 이미지로 변환
                    pil_img = Image.fromarray(cv2.cvtColor(frame.copy(), cv2.COLOR_BGR2RGB))
                    draw = ImageDraw.Draw(pil_img)

                    # 동적으로 최대 텍스트 너비 계산 (화면 크기에 비례)
                    max_text_width = int(width * self.max_text_width_ratio)

                    # 텍스트를 줄바꿈
                    wrapped_lines = self.wrap_text(self.overlay_text, self.pil_font, max_text_width)

                    # 전체 텍스트 영역의 크기 계산
                    line_heights = []
                    line_widths = []
                    for line in wrapped_lines:
                        bbox = draw.textbbox((0, 0), line, font=self.pil_font)
                        line_widths.append(bbox[2] - bbox[0])
                        line_heights.append(bbox[3] - bbox[1])

                    max_line_width = max(line_widths) if line_widths else 0
                    line_spacing = int(max(line_heights) * 0.2) if line_heights else 0
                    total_text_height = sum(line_heights) + line_spacing * (len(wrapped_lines) - 1)

                    # 텍스트 위치와 여백 계산
                    text_x = self.text_position[0]
                    text_y = self.text_position[1]
                    padding = self.text_padding

                    # 텍스트가 화면 오른쪽 밖으로 나가는 경우 조정
                    if text_x + max_line_width + padding * 2 > width:
                        text_x = width - max_line_width - padding * 2
                        if text_x < 0:
                            text_x = 0

                    # 텍스트가 화면 아래쪽 밖으로 나가는 경우 조정
                    if text_y + total_text_height + padding * 2 > height:
                        text_y = height - total_text_height - padding * 2
                        if text_y < 0:
                            text_y = 0

                    # 배경 박스 그리기 (화면 경계 체크)
                    bg_rect = (
                        max(0, text_x - padding),
                        max(0, text_y - padding),
                        min(width, text_x + max_line_width + padding),
                        min(height, text_y + total_text_height + padding)
                    )

                    overlay = Image.new('RGBA', pil_img.size, (0, 0, 0, 0))
                    overlay_draw = ImageDraw.Draw(overlay)
                    overlay_draw.rectangle(bg_rect, fill=(0, 0, 0, 180))
                    pil_img = Image.alpha_composite(pil_img.convert('RGBA'), overlay).convert('RGB')
                    draw = ImageDraw.Draw(pil_img)

                    # 각 줄 그리기
                    current_y = text_y
                    for line in wrapped_lines:
                        draw.text((text_x, current_y), line, font=self.pil_font, fill=(255, 255, 255))
                        bbox = draw.textbbox((0, 0), line, font=self.pil_font)
                        current_y += bbox[3] - bbox[1] + line_spacing

                    # PIL 이미지를 OpenCV 프레임으로 다시 변환
                    self.text_overlay_cache = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
                    self.last_overlay_text = self.overlay_text
                    self.last_text_position = self.text_position

                except Exception as text_error:
                    print(f"PIL 텍스트 렌더링 오류: {text_error}")
                    self.use_pil_for_text = False
                    self.text_overlay_cache = None

            # PIL을 사용할 수 없거나 오류가 발생한 경우 OpenCV로 텍스트 표시
            if not self.use_pil_for_text or not self.pil_font or self.text_overlay_cache is None:
                temp_frame = frame.copy()
                # OpenCV로는 기본적인 텍스트만 표시
                font = cv2.FONT_HERSHEY_SIMPLEX
                text_size = cv2.getTextSize(self.overlay_text, font,
                                            self.text_size / 30.0, self.text_thickness)[0]

                # 균형잡힌 여백 계산
                padding = self.text_padding

                # 배경 사각형 그리기
                bg_rect_x1 = max(0, self.text_position[0] - padding)
                bg_rect_y1 = max(0, self.text_position[1] - text_size[1] - padding)
                bg_rect_x2 = min(width, self.text_position[0] + text_size[0] + padding)
                bg_rect_y2 = min(height, self.text_position[1] + padding)

                # 검은색 배경
                cv2.rectangle(temp_frame, (bg_rect_x1, bg_rect_y1), (bg_rect_x2, bg_rect_y2),
                              (0, 0, 0), -1)

                # 흰색 텍스트
                cv2.putText(temp_frame, self.overlay_text, self.text_position, font,
                            self.text_size / 30.0, self.text_color, self.text_thickness, cv2.LINE_AA)
                
                self.text_overlay_cache = temp_frame
                self.last_overlay_text = self.overlay_text
                self.last_text_position = self.text_position
            
        # 캐시된 텍스트 오버레이 반환
        return self.text_overlay_cache

    def stop_recording(self):
        if not self.recording:
            return

        # 녹화 중지 플래그 설정 (스레드가 안전하게 종료되도록)
        self.recording = False

        # 마우스 리스너 중지
        self.stop_mouse_listener()

        # 스레드가 종료될 때까지 대기
        if self.video_thread and self.video_thread.is_alive():
            self.video_thread.join(timeout=2.0)  # 최대 2초 대기
            
        # 캡처 및 처리 스레드 정리
        if self.capture_thread and self.capture_thread.is_alive():
            self.capture_thread.join(timeout=1.0)
        if self.process_thread and self.process_thread.is_alive():
            self.process_thread.join(timeout=1.0)

        # 비디오 라이터 정리
        if self.video_writer:
            try:
                self.video_writer.release()
                self.video_writer = None
            except Exception as e:
                print(f"비디오 라이터 닫기 오류: {e}")

        # 녹화 중지 UI 업데이트
        self.record_button.config(text="녹화 시작")
        self.status_var.set("녹화 종료됨")

        # 파일 경로 및 형식 변경 활성화
        self.file_path_entry.config(state='normal')
        self.browse_button.config(state='normal')
        
        # 메모리 정리
        self.click_points.clear()
        self.mouse_trail_points.clear()
        self.current_trail.clear()
        self.text_overlay_cache = None
        self.frame_times.clear()
        
        # 버퍼 비우기
        while not self.frame_buffer.empty():
            try:
                self.frame_buffer.get_nowait()
            except Empty:
                break
        
        # 명시적 가비지 컬렉션
        gc.collect()
        
        # 출력 파일 확인
        output_file = self.file_path_var.get()
        if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
            self.status_var.set(f"녹화 완료: {output_file}")
        else:
            self.status_var.set("녹화 파일 저장 실패")

    def start_mouse_listener(self):
        """마우스 클릭 이벤트 리스너 시작"""

        # 마우스 이동과 클릭 감지
        def on_move(x, y):
            # 마우스 커서 위치 업데이트
            self.last_cursor_pos = (x, y)

            # 마우스 드래그 중인 경우 현재 경로 업데이트
            if self.is_mouse_dragging and self.show_mouse_trail.get():
                # 최소 거리 이상 움직였을 때만 포인트 추가 (성능 최적화)
                if not self.current_trail or self.distance(self.current_trail[-1], (x, y)) >= self.min_trail_point_distance:
                    self.current_trail.append((x, y))

        def on_click(x, y, button, pressed):
            # 마우스 버튼이 눌렸을 때 (pressed=True)
            if button == mouse.Button.left:
                if pressed:
                    # 클릭 위치와 시간 저장
                    self.click_points.append((x, y, time.time()))
                    if self.debug_mode:
                        print(f"마우스 클릭 포인트 추가: {x}, {y}")

                    # 드래그 시작
                    if self.show_mouse_trail.get():
                        self.is_mouse_dragging = True
                        self.current_trail = [(x, y)]
                else:
                    # 드래그 종료
                    if self.is_mouse_dragging and self.show_mouse_trail.get():
                        self.is_mouse_dragging = False
                        if len(self.current_trail) > 1:
                            self.mouse_trail_points.append((self.current_trail.copy(), time.time()))
                        self.current_trail = []

            # 녹화가 종료된 경우 리스너도 종료
            return self.recording

        # 마우스 리스너 시작
        try:
            self.mouse_listener = mouse.Listener(on_move=on_move, on_click=on_click)
            self.mouse_listener.start()
            if self.debug_mode:
                print("마우스 클릭 리스너 시작")
        except Exception as e:
            print(f"마우스 리스너 시작 오류: {e}")

    def stop_mouse_listener(self):
        """마우스 클릭 이벤트 리스너 중지"""
        if self.mouse_listener:
            try:
                self.mouse_listener.stop()
                if self.debug_mode:
                    print("마우스 클릭 리스너 중지")
            except Exception as e:
                print(f"마우스 리스너 중지 오류: {e}")
            self.mouse_listener = None

    def capture_screenshot(self):
        """스크린샷 캡처"""
        try:
            if self.capturing:
                return

            self.capturing = True
            self.status_var.set("스크린샷 캡처 중...")

            # 영역 선택
            if self.selected_area:
                screenshot = pyautogui.screenshot(region=self.selected_area)
            else:
                screenshot = pyautogui.screenshot()

            # 파일 저장 대화상자
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("JPEG files", "*.jpg"), ("All files", "*.*")],
                initialfile=f"screenshot_{timestamp}.png"
            )

            if file_path:
                screenshot.save(file_path)
                self.status_var.set(f"스크린샷 저장 완료: {file_path}")
            else:
                self.status_var.set("스크린샷 저장 취소됨")

            self.capturing = False

        except Exception as e:
            self.capturing = False
            self.status_var.set(f"스크린샷 캡처 오류: {str(e)}")
            messagebox.showerror("오류", f"스크린샷 캡처 중 오류가 발생했습니다: {str(e)}")

    def on_closing(self):
        """프로그램 종료 시 정리"""
        self.stop_mouse_listener()

        if self.recording:
            if messagebox.askyesno("확인", "녹화 중입니다. 정말 종료하시겠습니까?"):
                self.stop_recording()
            else:
                return  # 종료 취소

        # 비디오 라이터 정리
        if self.video_writer:
            try:
                self.video_writer.release()
            except:
                pass

        self.root.destroy()


# 메인 실행
if __name__ == "__main__":
    # 필요한 라이브러리 확인 및 설치 안내
    required_libraries = {
        "opencv-python": "cv2",
        "numpy": "numpy",
        "pyautogui": "pyautogui",
        "Pillow": "PIL",
        "pynput": "pynput",
        "screeninfo": "screeninfo"
    }

    missing_libraries = []
    for lib, import_name in required_libraries.items():
        try:
            # 일부 특수 케이스 처리
            if import_name == "PIL":
                import PIL
            else:
                __import__(import_name)
            print(f"√ {lib} 라이브러리 확인됨")
        except ImportError:
            missing_libraries.append(lib)
            print(f"× {lib} 라이브러리 없음")

    if missing_libraries:
        print("\n다음 라이브러리를 설치해야 합니다:")
        for lib in missing_libraries:
            print(f"- {lib}")
        print("\n다음 명령어로 설치할 수 있습니다:")
        print(f"pip install {' '.join(missing_libraries)}")

        if not messagebox.askyesno(
                "필수 라이브러리 없음",
                f"다음 라이브러리가 필요합니다:\n{', '.join(missing_libraries)}\n\n계속 진행하시겠습니까?"
        ):
            sys.exit(1)

    # 프로그램 시작
    try:
        print("\n화면 녹화 및 캡처 도구를 시작합니다...")
        root = tk.Tk()
        app = ScreenRecorderApp(root)
        root.mainloop()
    except Exception as e:
        print(f"프로그램 실행 중 오류가 발생했습니다: {e}")
        messagebox.showerror("오류", f"프로그램 실행 중 오류가 발생했습니다:\n{e}")
        sys.exit(1)
