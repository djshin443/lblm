import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import cv2
import numpy as np
import pyautogui
import threading
import time
import datetime
import os
from PIL import Image, ImageTk, ImageFont, ImageDraw
import sys
from pynput import mouse
import screeninfo
import textwrap


class ScreenRecorderApp:
    def __init__(self, root):
        self.root = root
        self.root.title("화면 녹화 및 캡처 도구")
        self.root.geometry("600x400")
        self.root.resizable(True, True)

        # 스타일 설정
        self.style = ttk.Style()
        self.style.configure('TButton', font=('Arial', 10))
        self.style.configure('TLabel', font=('Arial', 10))

        # 변수 초기화
        self.recording = False
        self.capturing = False
        self.selected_area = None
        self.frame_rate = 30.0
        self.output_file = None
        self.video_writer = None
        self.video_thread = None
        self.video_format = tk.StringVar(value="mp4")  # 기본값 MP4

        # 마우스 클릭 포인트 관련 변수
        self.click_points = []
        self.mouse_listener = None
        self.show_click_points = tk.BooleanVar(value=True)
        self.click_point_duration = 1.0  # 포인트 표시 지속 시간(초)

        # 마우스 드래그 선 그리기 관련 변수
        self.show_mouse_trail = tk.BooleanVar(value=False)
        self.mouse_trail_points = []
        self.is_mouse_dragging = False
        self.current_trail = []

        # 마우스 커서 표시 관련 변수
        self.show_cursor = tk.BooleanVar(value=True)  # 기본적으로 커서 표시
        self.cursor_size = 20  # 커서 크기
        self.last_cursor_pos = (0, 0)  # 마지막 커서 위치

        # 텍스트 오버레이 변수
        self.overlay_text = ""
        self.show_overlay_text = tk.BooleanVar(value=False)
        self.text_position = (20, 50)  # 기본 위치 (좌상단에서 조금 아래로)
        self.text_color = (255, 255, 255)  # 흰색 텍스트
        self.text_size = 30  # 폰트 크기 증가
        self.text_thickness = 2  # 텍스트 두께
        self.text_padding = 15  # 텍스트 주변 여백
        self.max_text_width_ratio = 0.8  # 화면 너비의 80%를 최대 텍스트 너비로 설정

        # 한글 표시를 위한 PIL 이미지 사용 여부
        self.use_pil_for_text = True
        self.pil_font = None  # 나중에 초기화

        # 모니터 정보
        self.monitors = screeninfo.get_monitors()
        self.selected_monitor = None

        # 메인 프레임
        main_frame = ttk.Frame(root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 위젯 생성
        self.create_widgets(main_frame)

        # 종료 시 정리
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        # 버튼 초기 상태 설정
        self.update_record_button_state()

        # 한글 폰트 초기화 시도
        self.init_korean_font()

    def init_korean_font(self):
        """한글 표시를 위한 PIL 폰트 초기화"""
        try:
            # Windows의 경우 맑은 고딕 폰트 사용
            if os.name == 'nt':
                font_path = os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Fonts', 'malgun.ttf')
                if os.path.exists(font_path):
                    self.pil_font = ImageFont.truetype(font_path, self.text_size)
                    return

            # macOS의 경우 애플고딕 폰트 사용
            if os.name == 'posix' and os.path.exists('/System/Library/Fonts'):
                font_path = '/System/Library/Fonts/AppleSDGothicNeo.ttc'
                if os.path.exists(font_path):
                    self.pil_font = ImageFont.truetype(font_path, self.text_size)
                    return

            # 기본 폰트 사용
            self.pil_font = ImageFont.load_default()

        except Exception as e:
            print(f"한글 폰트 초기화 오류: {e}")
            self.use_pil_for_text = False
            self.pil_font = None

    def wrap_text(self, text, font, max_width):
        """텍스트를 주어진 너비에 맞게 줄바꿈하는 함수"""
        if not text:
            return []

        # 임시 이미지와 드로우 객체 생성
        temp_img = Image.new('RGB', (1, 1))
        temp_draw = ImageDraw.Draw(temp_img)

        lines = []
        paragraphs = text.split('\n')  # 원래 줄바꿈 유지

        for paragraph in paragraphs:
            if not paragraph:
                lines.append("")
                continue

            words = paragraph.split()
            if not words:
                lines.append("")
                continue

            current_line = []
            current_width = 0

            for word in words:
                # 띄어쓰기를 포함한 단어
                word_with_space = word if not current_line else " " + word
                word_width = temp_draw.textlength(word_with_space, font=font)

                if current_width + word_width <= max_width or not current_line:
                    current_line.append(word_with_space.strip())
                    current_width += word_width
                else:
                    lines.append(" ".join(current_line))
                    current_line = [word]
                    current_width = temp_draw.textlength(word, font=font)

            if current_line:
                lines.append(" ".join(current_line))

        return lines

    def create_widgets(self, parent):
        # 상단 프레임 (녹화 설정)
        top_frame = ttk.LabelFrame(parent, text="녹화 설정", padding="10")
        top_frame.pack(fill=tk.X, padx=5, pady=5)

        # 출력 파일 선택
        file_frame = ttk.Frame(top_frame)
        file_frame.pack(fill=tk.X, pady=5)

        ttk.Label(file_frame, text="저장 위치:").pack(side=tk.LEFT, padx=5)
        self.file_path_var = tk.StringVar()
        self.file_path_var.trace("w", self.update_record_button_state)  # 파일 경로 변경 시 버튼 상태 업데이트
        self.file_path_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, width=40)
        self.file_path_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        self.browse_button = ttk.Button(file_frame, text="찾아보기", command=self.browse_output_file)
        self.browse_button.pack(side=tk.LEFT, padx=5)

        # 파일 형식 선택
        format_frame = ttk.Frame(top_frame)
        format_frame.pack(fill=tk.X, pady=5)

        ttk.Label(format_frame, text="파일 형식:").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(format_frame, text="MP4", variable=self.video_format, value="mp4").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(format_frame, text="AVI", variable=self.video_format, value="avi").pack(side=tk.LEFT, padx=5)

        # 녹화 옵션
        options_frame = ttk.Frame(top_frame)
        options_frame.pack(fill=tk.X, pady=5)

        ttk.Label(options_frame, text="프레임 레이트:").pack(side=tk.LEFT, padx=5)
        self.frame_rate_var = tk.StringVar(value="30")
        frame_rate_entry = ttk.Entry(options_frame, textvariable=self.frame_rate_var, width=5)
        frame_rate_entry.pack(side=tk.LEFT, padx=5)

        # 마우스 클릭 포인트 및 커서 표시 옵션
        mouse_options_frame = ttk.Frame(top_frame)
        mouse_options_frame.pack(fill=tk.X, pady=5)

        ttk.Checkbutton(mouse_options_frame, text="마우스 클릭 포인트 표시", variable=self.show_click_points).pack(side=tk.LEFT,
                                                                                                         padx=5)
        ttk.Checkbutton(mouse_options_frame, text="마우스 커서 표시", variable=self.show_cursor).pack(side=tk.LEFT, padx=20)
        ttk.Checkbutton(mouse_options_frame, text="마우스 드래그 선 표시", variable=self.show_mouse_trail).pack(side=tk.LEFT,
                                                                                                       padx=20)

        # 텍스트 오버레이 옵션
        text_overlay_frame = ttk.Frame(top_frame)
        text_overlay_frame.pack(fill=tk.X, pady=5)

        ttk.Checkbutton(text_overlay_frame, text="텍스트 표시", variable=self.show_overlay_text).pack(side=tk.LEFT, padx=5)
        ttk.Button(text_overlay_frame, text="텍스트 설정", command=self.set_overlay_text).pack(side=tk.LEFT, padx=5)

        # 현재 텍스트 표시
        self.overlay_text_var = tk.StringVar(value="텍스트 없음")
        ttk.Label(text_overlay_frame, textvariable=self.overlay_text_var, width=30, anchor=tk.W).pack(side=tk.LEFT,
                                                                                                      padx=5)

        # 녹화 컨트롤 프레임
        control_frame = ttk.Frame(parent)
        control_frame.pack(fill=tk.X, padx=5, pady=5)

        # 화면 캡처 영역 선택 버튼
        area_frame = ttk.Frame(control_frame)
        area_frame.pack(fill=tk.X, pady=5)

        ttk.Button(area_frame, text="화면 영역 선택", command=self.select_screen_area).pack(side=tk.LEFT, padx=5)
        ttk.Button(area_frame, text="모니터 선택", command=self.select_monitor).pack(side=tk.LEFT, padx=5)
        self.area_info_var = tk.StringVar(value="전체 화면")
        ttk.Label(area_frame, textvariable=self.area_info_var).pack(side=tk.LEFT, padx=5)

        # 녹화 및 캡처 버튼
        buttons_frame = ttk.Frame(control_frame)
        buttons_frame.pack(fill=tk.X, pady=10)

        self.record_button = ttk.Button(buttons_frame, text="녹화 시작", command=self.toggle_recording)
        self.record_button.pack(side=tk.LEFT, padx=5)

        ttk.Button(buttons_frame, text="스크린샷 캡처", command=self.capture_screenshot).pack(side=tk.LEFT, padx=5)

        # 상태 표시줄
        self.status_var = tk.StringVar(value="준비")
        ttk.Label(parent, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W).pack(fill=tk.X, padx=5, pady=5)

    def update_record_button_state(self, *args):
        """파일 경로 입력 여부에 따라 녹화 버튼 상태 업데이트"""
        if self.file_path_var.get().strip():
            self.record_button.config(state=tk.NORMAL)
        else:
            self.record_button.config(state=tk.DISABLED)

    def set_overlay_text(self):
        """텍스트 오버레이 설정 대화상자"""
        if self.recording:
            messagebox.showinfo("알림", "녹화 중에는 텍스트를 변경할 수 없습니다.")
            return

        # 텍스트 입력 대화창
        text = simpledialog.askstring("텍스트 입력", "화면에 표시할 텍스트를 입력하세요:",
                                      initialvalue=self.overlay_text)

        if text is not None:  # 취소를 누르지 않았으면
            self.overlay_text = text
            if text:
                self.overlay_text_var.set(f"텍스트: {text[:20]}{'...' if len(text) > 20 else ''}")
                self.show_overlay_text.set(True)
            else:
                self.overlay_text_var.set("텍스트 없음")
                self.show_overlay_text.set(False)

    def browse_output_file(self):
        # 현재 선택된 파일 형식에 따라 확장자 결정
        file_ext = "." + self.video_format.get()

        file_path = filedialog.asksaveasfilename(
            defaultextension=file_ext,
            filetypes=[
                ("MP4 files", "*.mp4"),
                ("AVI files", "*.avi"),
                ("All files", "*.*")
            ]
        )
        if file_path:
            self.file_path_var.set(file_path)

    def select_monitor(self):
        """모니터 선택 대화상자"""
        # 모니터 선택 창
        monitor_window = tk.Toplevel(self.root)
        monitor_window.title("모니터 선택")
        monitor_window.geometry("400x300")
        monitor_window.transient(self.root)
        monitor_window.grab_set()

        ttk.Label(monitor_window, text="녹화할 모니터를 선택하세요:", font=('Arial', 12)).pack(pady=10)

        # 모니터 목록
        listbox = tk.Listbox(monitor_window, selectmode=tk.SINGLE, font=('Arial', 10))
        listbox.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        for i, monitor in enumerate(self.monitors):
            listbox.insert(tk.END, f"모니터 {i + 1}: {monitor.width}x{monitor.height} (위치: {monitor.x}, {monitor.y})")

        def on_select():
            selection = listbox.curselection()
            if selection:
                self.selected_monitor = self.monitors[selection[0]]
                self.selected_area = (self.selected_monitor.x, self.selected_monitor.y,
                                      self.selected_monitor.width, self.selected_monitor.height)
                self.area_info_var.set(f"모니터 {selection[0] + 1} 선택됨")
                monitor_window.destroy()
            else:
                messagebox.showwarning("경고", "모니터를 선택해주세요.")

        ttk.Button(monitor_window, text="선택", command=on_select).pack(pady=10)

    def select_screen_area(self):
        # 현재 창 최소화
        self.root.iconify()
        time.sleep(0.5)  # 창이 최소화될 시간 부여

        # 새 창 생성 (전체 화면)
        selection_window = tk.Toplevel()
        selection_window.attributes('-fullscreen', True)
        selection_window.attributes('-alpha', 0.3)  # 반투명 화면

        # 선택 영역 변수
        start_x = start_y = end_x = end_y = 0
        selection_rect = None

        # 마우스 이벤트 처리
        def on_mouse_down(event):
            nonlocal start_x, start_y, selection_rect
            start_x, start_y = event.x, event.y
            if selection_rect:
                selection_window.canvas.delete(selection_rect)
            selection_rect = selection_window.canvas.create_rectangle(
                start_x, start_y, start_x, start_y,
                outline="red", width=2
            )

        def on_mouse_move(event):
            nonlocal selection_rect, start_x, start_y
            if selection_rect:
                end_x, end_y = event.x, event.y
                selection_window.canvas.coords(selection_rect, start_x, start_y, end_x, end_y)

        def on_mouse_up(event):
            nonlocal start_x, start_y, end_x, end_y
            end_x, end_y = event.x, event.y

            # 좌표 정규화 (시작점이 항상 왼쪽 위)
            if start_x > end_x:
                start_x, end_x = end_x, start_x
            if start_y > end_y:
                start_y, end_y = end_y, start_y

            # 창 닫기
            selection_window.destroy()

            # 선택된 영역 저장
            width = end_x - start_x
            height = end_y - start_y

            # 너무 작은 영역은 무시
            if width < 10 or height < 10:
                messagebox.showwarning("경고", "선택한 영역이 너무 작습니다. 다시 선택해주세요.")
                self.root.deiconify()
                return

            self.selected_area = (start_x, start_y, width, height)
            self.area_info_var.set(f"선택 영역: {start_x}, {start_y}, {width} x {height}")

            # 메인 창 복원
            self.root.deiconify()

        # 취소 처리
        def on_cancel(event=None):
            selection_window.destroy()
            self.root.deiconify()

        # 캔버스 생성
        selection_window.canvas = tk.Canvas(selection_window, cursor="cross")
        selection_window.canvas.pack(fill=tk.BOTH, expand=True)

        # 이벤트 바인딩
        selection_window.canvas.bind("<ButtonPress-1>", on_mouse_down)
        selection_window.canvas.bind("<B1-Motion>", on_mouse_move)
        selection_window.canvas.bind("<ButtonRelease-1>", on_mouse_up)
        selection_window.bind("<Escape>", on_cancel)

        # 안내 텍스트
        selection_window.canvas.create_text(
            selection_window.winfo_screenwidth() // 2,
            selection_window.winfo_screenheight() // 2,
            text="마우스로 드래그하여 화면 영역을 선택하세요. (ESC: 취소)",
            fill="white", font=("Arial", 16)
        )

    def toggle_recording(self):
        if not self.recording:
            self.start_recording()
        else:
            self.stop_recording()

    def start_recording(self):
        # 파일 경로 확인
        output_file = self.file_path_var.get().strip()
        if not output_file:
            messagebox.showwarning("경고", "저장 경로를 지정해주세요.")
            return

        # 파일 형식 가져오기
        file_format = self.video_format.get()

        # 확장자 확인 및 수정
        if not (output_file.lower().endswith(f".{file_format}")):
            output_file = f"{output_file}.{file_format}"
            self.file_path_var.set(output_file)

        # 이미 파일이 존재하는지 확인
        if os.path.exists(output_file):
            if not messagebox.askyesno("확인", f"파일 '{output_file}'이(가) 이미 존재합니다. 덮어쓰시겠습니까?"):
                return

        # 녹화 설정
        try:
            self.frame_rate = float(self.frame_rate_var.get())
            if self.frame_rate <= 0:
                self.frame_rate = 30.0
                self.frame_rate_var.set("30")
        except ValueError:
            self.frame_rate = 30.0
            self.frame_rate_var.set("30")

        # 화면 크기 결정
        if self.selected_area:
            x, y, width, height = self.selected_area
        else:
            # 전체 화면
            width, height = pyautogui.size()
            x, y = 0, 0

        # 비디오 형식에 따른 코덱 선택
        fourcc_code = 'mp4v' if file_format == 'mp4' else 'XVID'  # AVI는 XVID 코덱 사용

        # 비디오 라이터 설정 - 실시간 저장을 위해 직접 파일에 쓰기
        fourcc = cv2.VideoWriter_fourcc(*fourcc_code)
        self.video_writer = cv2.VideoWriter(output_file, fourcc, self.frame_rate, (width, height))

        if not self.video_writer.isOpened():
            messagebox.showerror("오류", f"비디오 파일을 생성할 수 없습니다. 형식: {file_format}, 코덱: {fourcc_code}")
            return

        # 파일 디렉토리에 대한 쓰기 권한 확인
        try:
            output_dir = os.path.dirname(output_file)
            if output_dir and not os.access(output_dir, os.W_OK):
                messagebox.showerror("오류", f"폴더에 쓰기 권한이 없습니다: {output_dir}")
                return
        except Exception as e:
            print(f"디렉토리 권한 확인 오류: {e}")

        # 녹화 시작
        self.recording = True
        self.record_button.config(text="녹화 중지")
        self.status_var.set("녹화 중...")

        # 파일 경로 및 형식 변경 비활성화
        self.file_path_entry.config(state='disabled')
        self.browse_button.config(state='disabled')

        # 클릭 포인트 초기화
        self.click_points = []
        self.mouse_trail_points = []
        self.current_trail = []

        # 마우스 리스너 시작
        if self.show_click_points.get() or self.show_cursor.get() or self.show_mouse_trail.get():
            self.start_mouse_listener()

        # 녹화 스레드 시작
        self.video_thread = threading.Thread(target=self._video_recording_thread)
        self.video_thread.daemon = True
        self.video_thread.start()

    def stop_recording(self):
        if not self.recording:
            return

        # 녹화 중지 플래그 설정 (스레드가 안전하게 종료되도록)
        self.recording = False

        # 마우스 리스너 중지
        self.stop_mouse_listener()

        # 스레드가 종료될 때까지 대기
        if self.video_thread and self.video_thread.is_alive():
            self.video_thread.join(timeout=2.0)  # 최대 2초 대기

        # 녹화 중지 UI 업데이트
        self.record_button.config(text="녹화 시작")
        self.status_var.set("녹화 종료됨")

        # 파일 경로 및 형식 변경 활성화
        self.file_path_entry.config(state='normal')
        self.browse_button.config(state='normal')

    def _video_recording_thread(self):
        try:
            # 화면 크기 결정
            if self.selected_area:
                x, y, width, height = self.selected_area
            else:
                # 전체 화면
                width, height = pyautogui.size()
                x, y = 0, 0

            # 녹화 시작 시간
            start_time = time.time()
            frames_captured = 0

            # 녹화 루프
            while self.recording:
                # video_writer가 None인지 확인
                if not self.video_writer or not self.video_writer.isOpened():
                    print("비디오 라이터가 닫혔거나 없습니다. 녹화를 중지합니다.")
                    self.recording = False
                    break

                # 화면 캡처
                screenshot = pyautogui.screenshot(region=(x, y, width, height))
                frame = np.array(screenshot)
                frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

                # 마우스 드래그 선 표시
                if self.show_mouse_trail.get():
                    # 현재 드래그 중인 선 그리기
                    if self.is_mouse_dragging and len(self.current_trail) > 1:
                        for i in range(len(self.current_trail) - 1):
                            start_point = self.current_trail[i]
                            end_point = self.current_trail[i + 1]

                            # 선택된 영역이 있는 경우 좌표 조정
                            if self.selected_area:
                                start_x, start_y = start_point[0] - x, start_point[1] - y
                                end_x, end_y = end_point[0] - x, end_point[1] - y

                                # 화면 영역 내부에 있는 경우만 그리기
                                if (0 <= start_x < width and 0 <= start_y < height and
                                        0 <= end_x < width and 0 <= end_y < height):
                                    cv2.line(frame, (start_x, start_y), (end_x, end_y), (0, 0, 255), 2)
                            else:
                                cv2.line(frame, start_point, end_point, (0, 0, 255), 2)

                    # 이전에 그린 선들도 표시 (페이드 아웃 효과)
                    current_time = time.time()
                    for trail in self.mouse_trail_points:
                        points, trail_time = trail
                        fade_factor = max(0, 1 - (current_time - trail_time) / 2.0)  # 2초 동안 페이드 아웃
                        if fade_factor > 0:
                            for i in range(len(points) - 1):
                                start_point = points[i]
                                end_point = points[i + 1]

                                if self.selected_area:
                                    start_x, start_y = start_point[0] - x, start_point[1] - y
                                    end_x, end_y = end_point[0] - x, end_point[1] - y

                                    if (0 <= start_x < width and 0 <= start_y < height and
                                            0 <= end_x < width and 0 <= end_y < height):
                                        color = (0, 0, int(255 * fade_factor))
                                        cv2.line(frame, (start_x, start_y), (end_x, end_y), color, 2)
                                else:
                                    color = (0, 0, int(255 * fade_factor))
                                    cv2.line(frame, start_point, end_point, color, 2)

                # 마우스 클릭 포인트 표시
                if self.show_click_points.get():
                    current_time = time.time()
                    # 클릭 포인트 그리기
                    for click_point in self.click_points:
                        click_x, click_y, click_time = click_point
                        # 선택된 영역이 있는 경우 좌표 조정
                        if self.selected_area:
                            relative_x = click_x - x
                            relative_y = click_y - y
                            # 화면 영역 내부에 있는 클릭만 표시
                            if 0 <= relative_x < width and 0 <= relative_y < height:
                                # 클릭 후 지속 시간 이내인 경우만 표시
                                if current_time - click_time <= self.click_point_duration:
                                    # 시간에 따라 크기와 투명도 조절
                                    time_ratio = 1 - (current_time - click_time) / self.click_point_duration
                                    radius = int(10 * time_ratio) + 5
                                    cv2.circle(frame, (relative_x, relative_y), radius, (0, 0, 255), -1)
                        else:
                            # 전체 화면인 경우 바로 표시
                            if current_time - click_time <= self.click_point_duration:
                                time_ratio = 1 - (current_time - click_time) / self.click_point_duration
                                radius = int(10 * time_ratio) + 5
                                cv2.circle(frame, (click_x, click_y), radius, (0, 0, 255), -1)

                # 마우스 커서 표시
                if self.show_cursor.get():
                    cursor_x, cursor_y = self.last_cursor_pos
                    # 선택된 영역이 있는 경우 좌표 조정
                    if self.selected_area:
                        relative_x = cursor_x - x
                        relative_y = cursor_y - y
                        # 화면 영역 내부에 있는 커서만 표시
                        if 0 <= relative_x < width and 0 <= relative_y < height:
                            # 간단한 십자 모양 커서 그리기
                            cursor_size = self.cursor_size
                            cv2.line(frame, (relative_x - cursor_size // 2, relative_y),
                                     (relative_x + cursor_size // 2, relative_y), (0, 255, 0), 2)
                            cv2.line(frame, (relative_x, relative_y - cursor_size // 2),
                                     (relative_x, relative_y + cursor_size // 2), (0, 255, 0), 2)
                    else:
                        # 전체 화면인 경우 바로 표시
                        if 0 <= cursor_x < width and 0 <= cursor_y < height:
                            # 간단한 십자 모양 커서 그리기
                            cursor_size = self.cursor_size
                            cv2.line(frame, (cursor_x - cursor_size // 2, cursor_y),
                                     (cursor_x + cursor_size // 2, cursor_y), (0, 255, 0), 2)
                            cv2.line(frame, (cursor_x, cursor_y - cursor_size // 2),
                                     (cursor_x, cursor_y + cursor_size // 2), (0, 255, 0), 2)

                # 텍스트 오버레이 표시
                if self.show_overlay_text.get() and self.overlay_text:
                    if self.use_pil_for_text and self.pil_font:
                        try:
                            # OpenCV 프레임을 PIL 이미지로 변환
                            pil_img = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
                            draw = ImageDraw.Draw(pil_img)

                            # 동적으로 최대 텍스트 너비 계산 (화면 크기에 비례)
                            max_text_width = int(width * self.max_text_width_ratio)

                            # 텍스트를 줄바꿈
                            wrapped_lines = self.wrap_text(self.overlay_text, self.pil_font, max_text_width)

                            # 전체 텍스트 영역의 크기 계산
                            line_heights = []
                            line_widths = []
                            for line in wrapped_lines:
                                bbox = draw.textbbox((0, 0), line, font=self.pil_font)
                                line_widths.append(bbox[2] - bbox[0])
                                line_heights.append(bbox[3] - bbox[1])

                            max_line_width = max(line_widths) if line_widths else 0
                            line_spacing = int(max(line_heights) * 0.2) if line_heights else 0
                            total_text_height = sum(line_heights) + line_spacing * (len(wrapped_lines) - 1)

                            # 텍스트 위치와 여백 계산
                            text_x = self.text_position[0]
                            text_y = self.text_position[1]
                            padding = self.text_padding

                            # 텍스트가 화면 오른쪽 밖으로 나가는 경우 조정
                            if text_x + max_line_width + padding * 2 > width:
                                text_x = width - max_line_width - padding * 2
                                if text_x < 0:
                                    text_x = 0

                            # 텍스트가 화면 아래쪽 밖으로 나가는 경우 조정
                            if text_y + total_text_height + padding * 2 > height:
                                text_y = height - total_text_height - padding * 2
                                if text_y < 0:
                                    text_y = 0

                            # 배경 박스 그리기 (화면 경계 체크)
                            bg_rect = (
                                max(0, text_x - padding),
                                max(0, text_y - padding),
                                min(width, text_x + max_line_width + padding),
                                min(height, text_y + total_text_height + padding)
                            )

                            overlay = Image.new('RGBA', pil_img.size, (0, 0, 0, 0))
                            overlay_draw = ImageDraw.Draw(overlay)
                            overlay_draw.rectangle(bg_rect, fill=(0, 0, 0, 180))
                            pil_img = Image.alpha_composite(pil_img.convert('RGBA'), overlay).convert('RGB')
                            draw = ImageDraw.Draw(pil_img)

                            # 각 줄 그리기
                            current_y = text_y
                            for line in wrapped_lines:
                                draw.text((text_x, current_y), line, font=self.pil_font, fill=(255, 255, 255))
                                bbox = draw.textbbox((0, 0), line, font=self.pil_font)
                                current_y += bbox[3] - bbox[1] + line_spacing

                            # PIL 이미지를 OpenCV 프레임으로 다시 변환
                            frame = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

                        except Exception as text_error:
                            print(f"PIL 텍스트 렌더링 오류: {text_error}")
                            self.use_pil_for_text = False

                    # PIL을 사용할 수 없거나 오류가 발생한 경우 OpenCV로 텍스트 표시
                    if not self.use_pil_for_text or not self.pil_font:
                        # OpenCV로는 기본적인 텍스트만 표시
                        font = cv2.FONT_HERSHEY_SIMPLEX
                        text_size = cv2.getTextSize(self.overlay_text, font,
                                                    self.text_size / 30.0, self.text_thickness)[0]

                        # 균형잡힌 여백 계산
                        padding = self.text_padding

                        # 배경 사각형 그리기
                        bg_rect_x1 = self.text_position[0] - padding
                        bg_rect_y1 = self.text_position[1] - text_size[1] - padding
                        bg_rect_x2 = self.text_position[0] + text_size[0] + padding
                        bg_rect_y2 = self.text_position[1] + padding

                        # 검은색 배경
                        cv2.rectangle(frame, (bg_rect_x1, bg_rect_y1), (bg_rect_x2, bg_rect_y2),
                                      (0, 0, 0), -1)

                        # 흰색 텍스트
                        cv2.putText(frame, self.overlay_text, self.text_position, font,
                                    self.text_size / 30.0, self.text_color, self.text_thickness, cv2.LINE_AA)

                # 비디오에 프레임 추가
                try:
                    # video_writer가 유효한지 확인
                    if self.video_writer and self.video_writer.isOpened():
                        self.video_writer.write(frame)
                        frames_captured += 1
                    else:
                        print("비디오 라이터가 유효하지 않습니다.")
                        self.recording = False
                        break
                except Exception as write_error:
                    print(f"프레임 쓰기 오류: {write_error}")
                    self.recording = False
                    break

                # 캡처 주기 계산 (프레임 레이트 유지)
                elapsed_time = time.time() - start_time
                expected_frames = elapsed_time * self.frame_rate
                if frames_captured > expected_frames:
                    # 너무 빠르게 캡처 중이므로 잠시 대기
                    time.sleep(1 / self.frame_rate)

                # UI 업데이트
                recording_time = int(elapsed_time)
                self.root.after_idle(
                    lambda t=recording_time: self.status_var.set(f"녹화 중... {t // 60:02d}:{t % 60:02d}")
                )

            # 녹화 종료 메시지
            if not self.recording:
                print("녹화가 정상적으로 종료되었습니다.")

        except Exception as e:
            error_msg = str(e)
            print(f"비디오 녹화 오류: {error_msg}")
            self.root.after_idle(
                lambda msg=error_msg: [
                    self.status_var.set(f"비디오 녹화 오류: {msg}"),
                    messagebox.showerror("오류", f"녹화 중 오류가 발생했습니다: {msg}")
                ]
            )
            # 오류 발생 시 녹화 중지
            self.recording = False

        finally:
            # 항상 실행되는 정리 코드
            if self.video_writer:
                try:
                    self.video_writer.release()
                    self.video_writer = None
                    # 파일이 제대로 저장되었는지 확인
                    output_file = self.file_path_var.get()
                    if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                        self.root.after_idle(
                            lambda: self.status_var.set(f"녹화 완료: {output_file}")
                        )
                    else:
                        self.root.after_idle(
                            lambda: self.status_var.set("녹화 파일 저장 실패")
                        )
                except Exception as close_error:
                    print(f"비디오 라이터 닫기 오류: {close_error}")
                    self.root.after_idle(
                        lambda: self.status_var.set(f"비디오 파일 닫기 오류: {close_error}")
                    )

            # 녹화 상태 초기화
            self.recording = False

            # 파일 경로 및 형식 변경 활성화
            self.root.after_idle(lambda: [
                self.file_path_entry.config(state='normal'),
                self.browse_button.config(state='normal'),
                self.record_button.config(text="녹화 시작")
            ])

    def start_mouse_listener(self):
        """마우스 클릭 이벤트 리스너 시작"""

        # 마우스 이동과 클릭 감지
        def on_move(x, y):
            # 마우스 커서 위치 업데이트
            self.last_cursor_pos = (x, y)

            # 마우스 드래그 중인 경우 현재 경로 업데이트
            if self.is_mouse_dragging and self.show_mouse_trail.get():
                self.current_trail.append((x, y))

        def on_click(x, y, button, pressed):
            # 마우스 버튼이 눌렸을 때 (pressed=True)
            if button == mouse.Button.left:
                if pressed:
                    # 클릭 위치와 시간 저장
                    self.click_points.append((x, y, time.time()))
                    print(f"마우스 클릭 포인트 추가: {x}, {y}")

                    # 드래그 시작
                    if self.show_mouse_trail.get():
                        self.is_mouse_dragging = True
                        self.current_trail = [(x, y)]

                    # 오래된 클릭 포인트 제거 (메모리 관리)
                    current_time = time.time()
                    self.click_points = [p for p in self.click_points
                                         if current_time - p[2] <= self.click_point_duration + 0.5]
                else:
                    # 드래그 종료
                    if self.is_mouse_dragging and self.show_mouse_trail.get():
                        self.is_mouse_dragging = False
                        if len(self.current_trail) > 1:
                            self.mouse_trail_points.append((self.current_trail.copy(), time.time()))
                            # 오래된 트레일 제거 (2초 이상 된 것)
                            current_time = time.time()
                            self.mouse_trail_points = [trail for trail in self.mouse_trail_points
                                                       if current_time - trail[1] <= 2.0]
                        self.current_trail = []

            # 녹화가 종료된 경우 리스너도 종료
            return self.recording

        # 마우스 리스너 시작
        try:
            self.mouse_listener = mouse.Listener(on_move=on_move, on_click=on_click)
            self.mouse_listener.start()
            print("마우스 클릭 리스너 시작")
        except Exception as e:
            print(f"마우스 리스너 시작 오류: {e}")

    def stop_mouse_listener(self):
        """마우스 클릭 이벤트 리스너 중지"""
        if self.mouse_listener:
            try:
                self.mouse_listener.stop()
                print("마우스 클릭 리스너 중지")
            except Exception as e:
                print(f"마우스 리스너 중지 오류: {e}")
            self.mouse_listener = None

    def capture_screenshot(self):
        """스크린샷 캡처"""
        try:
            if self.capturing:
                return

            self.capturing = True
            self.status_var.set("스크린샷 캡처 중...")

            # 영역 선택
            if self.selected_area:
                screenshot = pyautogui.screenshot(region=self.selected_area)
            else:
                screenshot = pyautogui.screenshot()

            # 파일 저장 대화상자
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("JPEG files", "*.jpg"), ("All files", "*.*")],
                initialfile=f"screenshot_{timestamp}.png"
            )

            if file_path:
                screenshot.save(file_path)
                self.status_var.set(f"스크린샷 저장 완료: {file_path}")
            else:
                self.status_var.set("스크린샷 저장 취소됨")

            self.capturing = False

        except Exception as e:
            self.capturing = False
            self.status_var.set(f"스크린샷 캡처 오류: {str(e)}")
            messagebox.showerror("오류", f"스크린샷 캡처 중 오류가 발생했습니다: {str(e)}")

    def on_closing(self):
        """프로그램 종료 시 정리"""
        self.stop_mouse_listener()

        if self.recording:
            if messagebox.askyesno("확인", "녹화 중입니다. 정말 종료하시겠습니까?"):
                self.stop_recording()
            else:
                return  # 종료 취소

        # 비디오 라이터 정리
        if self.video_writer:
            try:
                self.video_writer.release()
            except:
                pass

        self.root.destroy()


# 메인 실행
if __name__ == "__main__":
    # 필요한 라이브러리 확인 및 설치 안내
    required_libraries = {
        "opencv-python": "cv2",
        "numpy": "numpy",
        "pyautogui": "pyautogui",
        "Pillow": "PIL",
        "pynput": "pynput",
        "screeninfo": "screeninfo"
    }

    missing_libraries = []
    for lib, import_name in required_libraries.items():
        try:
            # 일부 특수 케이스 처리
            if import_name == "PIL":
                import PIL
            else:
                __import__(import_name)
            print(f"√ {lib} 라이브러리 확인됨")
        except ImportError:
            missing_libraries.append(lib)
            print(f"× {lib} 라이브러리 없음")

    if missing_libraries:
        print("\n다음 라이브러리를 설치해야 합니다:")
        for lib in missing_libraries:
            print(f"- {lib}")
        print("\n다음 명령어로 설치할 수 있습니다:")
        print(f"pip install {' '.join(missing_libraries)}")

        if not messagebox.askyesno(
                "필수 라이브러리 없음",
                f"다음 라이브러리가 필요합니다:\n{', '.join(missing_libraries)}\n\n계속 진행하시겠습니까?"
        ):
            sys.exit(1)

    # 프로그램 시작
    try:
        print("\n화면 녹화 및 캡처 도구를 시작합니다...")
        root = tk.Tk()
        app = ScreenRecorderApp(root)
        root.mainloop()
    except Exception as e:
        print(f"프로그램 실행 중 오류가 발생했습니다: {e}")
        messagebox.showerror("오류", f"프로그램 실행 중 오류가 발생했습니다:\n{e}")
        sys.exit(1)
