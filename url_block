import sys
import os
import requests
import time
import logging
import csv
from urllib.parse import urlparse, unquote
from datetime import datetime, timedelta
import signal
import psutil
import atexit
import shutil
import gc
import tempfile
import glob

# Windows 전용 모듈
import ctypes
from ctypes import wintypes

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QGridLayout, QLabel, QLineEdit, QPushButton, QSpinBox, \
    QComboBox, QTextEdit, QHBoxLayout, QFileDialog, QCheckBox, QMessageBox, QProgressBar, QSystemTrayIcon, QMenu
from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QMutex, QWaitCondition
from PyQt5.QtGui import QColor, QPalette, QIcon
import urllib3
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException, NoSuchWindowException

# 로깅 설정
log_directory = os.path.join(os.getcwd(), "logs")
if not os.path.exists(log_directory):
    os.makedirs(log_directory)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_directory, f"app_{datetime.now().strftime('%y%m%d%H%M%S')}.log")),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger()

# InsecureRequestWarning 경고를 무시합니다.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Windows API 상수
TH32CS_SNAPPROCESS = 0x00000002
PROCESS_TERMINATE = 0x0001
INVALID_HANDLE_VALUE = -1

# 메모리 관리 상수
MAX_MEMORY_PERCENT = 80  # 최대 메모리 사용량 비율 (%)
LOG_RETENTION_DAYS = 7  # 로그 보관 기간 (일)
MAX_LOG_SIZE_MB = 50  # 최대 로그 파일 크기 (MB)
MEMORY_CHECK_INTERVAL = 5 * 60 * 1000  # 메모리 확인 간격 (ms): 5분
CHROME_TEMP_PROFILE_BASE = os.path.join(tempfile.gettempdir(), "chrome_profiles")


# Windows API 구조체
class PROCESSENTRY32(ctypes.Structure):
    _fields_ = [
        ("dwSize", wintypes.DWORD),
        ("cntUsage", wintypes.DWORD),
        ("th32ProcessID", wintypes.DWORD),
        ("th32DefaultHeapID", ctypes.POINTER(wintypes.ULONG)),
        ("th32ModuleID", wintypes.DWORD),
        ("cntThreads", wintypes.DWORD),
        ("th32ParentProcessID", wintypes.DWORD),
        ("pcPriClassBase", wintypes.LONG),
        ("dwFlags", wintypes.DWORD),
        ("szExeFile", ctypes.c_char * 260)  # c_char 사용
    ]


# Windows API 함수
kernel32 = ctypes.windll.kernel32
CreateToolhelp32Snapshot = kernel32.CreateToolhelp32Snapshot
Process32First = kernel32.Process32First
Process32Next = kernel32.Process32Next
CloseHandle = kernel32.CloseHandle
OpenProcess = kernel32.OpenProcess
TerminateProcess = kernel32.TerminateProcess


def is_process_running(process_name):
    """프로세스 이름으로 실행 중인지 확인"""
    for proc in psutil.process_iter(['name']):
        try:
            if process_name.lower() in proc.info['name'].lower():
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False


def terminate_process_by_name(process_name):
    """프로세스 이름으로 강제 종료 (psutil 사용)"""
    try:
        terminated = False
        for proc in psutil.process_iter(['name', 'pid']):
            try:
                if process_name.lower() in proc.info['name'].lower():
                    pid = proc.info['pid']
                    process = psutil.Process(pid)
                    process.terminate()  # 정상 종료 시도

                    # 종료 대기 (최대 3초)
                    gone, still_alive = psutil.wait_procs([process], timeout=3)

                    # 여전히 살아있다면 강제 종료
                    if still_alive:
                        process.kill()

                    logger.info(f"프로세스 종료 성공: {process_name} (PID: {pid})")
                    terminated = True
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                logger.error(f"프로세스 접근 오류: {str(e)}")
            except Exception as e:
                logger.error(f"프로세스 종료 중 오류 발생: {str(e)}")

        return terminated
    except Exception as e:
        logger.error(f"프로세스 종료 중 오류 발생: {str(e)}")
        return False


def kill_all_chrome_drivers():
    """모든 chromedriver 프로세스 종료"""
    try:
        terminate_process_by_name("chromedriver.exe")
    except Exception as e:
        logger.error(f"ChromeDriver 종료 중 오류: {str(e)}")


def kill_all_chrome_processes():
    """모든 Chrome 프로세스 종료"""
    terminate_process_by_name("chrome.exe")


def set_process_priority_high():
    """현재 프로세스의 우선순위를 높게 설정"""
    try:
        # Windows에서의 높은 우선순위 설정
        p = psutil.Process(os.getpid())
        p.nice(psutil.HIGH_PRIORITY_CLASS)
        logger.info("프로세스 우선순위가 높게 설정되었습니다.")
    except Exception as e:
        logger.error(f"프로세스 우선순위 설정 오류: {str(e)}")


def register_exit_handlers():
    """프로그램 종료 시 실행할 처리기 등록"""
    atexit.register(kill_all_chrome_drivers)
    atexit.register(cleanup_temp_profiles)


def cleanup_temp_profiles():
    """임시 Chrome 프로필 디렉토리 정리"""
    try:
        if os.path.exists(CHROME_TEMP_PROFILE_BASE):
            # 기존 코드는 rmtree로 전체 디렉토리를 삭제했지만,
            # 더 안전하게 48시간 이상 된 프로필만 삭제하도록 개선
            current_time = time.time()
            deleted_count = 0

            for item in os.listdir(CHROME_TEMP_PROFILE_BASE):
                item_path = os.path.join(CHROME_TEMP_PROFILE_BASE, item)

                # 디렉토리만 처리
                if os.path.isdir(item_path):
                    # 48시간(172800초) 이상 된 디렉토리만 삭제
                    if current_time - os.path.getmtime(item_path) > 172800:
                        try:
                            shutil.rmtree(item_path, ignore_errors=True)
                            deleted_count += 1
                        except Exception as e:
                            logger.error(f"임시 프로필 디렉토리 삭제 오류: {item_path} - {str(e)}")

            logger.info(f"임시 Chrome 프로필 디렉토리 정리 완료: {deleted_count}개 삭제됨")

            # 전체 프로필 디렉토리 크기 확인 및 경고
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(CHROME_TEMP_PROFILE_BASE):
                for f in filenames:
                    fp = os.path.join(dirpath, f)
                    total_size += os.path.getsize(fp)

            total_size_mb = total_size / (1024 * 1024)
            if total_size_mb > 500:  # 500MB 이상이면 경고
                logger.warning(f"임시 프로필 디렉토리 크기가 큽니다: {total_size_mb:.2f}MB")
    except Exception as e:
        logger.error(f"임시 프로필 정리 중 오류 발생: {str(e)}")


def create_temp_profile():
    """임시 Chrome 프로필 디렉토리 생성"""
    if not os.path.exists(CHROME_TEMP_PROFILE_BASE):
        os.makedirs(CHROME_TEMP_PROFILE_BASE)

    # 고유한 프로필 디렉터리 생성
    profile_dir = os.path.join(CHROME_TEMP_PROFILE_BASE, f"profile_{datetime.now().strftime('%Y%m%d%H%M%S%f')}")
    os.makedirs(profile_dir, exist_ok=True)
    return profile_dir


def get_chrome_version():
    """Windows에서 Chrome 버전 확인"""
    try:
        # Windows의 경우 레지스트리에서 크롬 버전 확인
        if sys.platform == 'win32':
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Google\Chrome\BLBeacon')
            version, _ = winreg.QueryValueEx(key, 'version')
            return version
    except Exception as e:
        logger.error(f"레지스트리에서 Chrome 버전 확인 실패: {str(e)}")
        try:
            # 레지스트리에서 실패할 경우 기본 경로에서 확인 시도
            paths = [
                r'C:\Program Files\Google\Chrome\Application\chrome.exe',
                r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe',
                os.path.expandvars(r'%LocalAppData%\Google\Chrome\Application\chrome.exe')
            ]

            from win32com.client import Dispatch
            parser = Dispatch('Scripting.FileSystemObject')

            for path in paths:
                if os.path.exists(path):
                    version = parser.GetFileVersion(path)
                    return version
        except Exception as e:
            logger.error(f"파일에서 Chrome 버전 확인 실패: {str(e)}")

    return None


def setup_driver(debug=False, use_temp_profile=True):
    """향상된 크롬 드라이버 설정"""
    options = Options()

    try:
        # 1. 크롬 버전 확인
        chrome_version = get_chrome_version()
        if not chrome_version:
            raise Exception("Chrome 버전을 확인할 수 없습니다.")

        logger.info(f"감지된 Chrome 버전: {chrome_version}")
        major_version = chrome_version.split('.')[0]  # 메이저 버전만 추출

        # 2. 크롬드라이버 다운로드 URL 구성
        driver_version = chrome_version  # 크롬 버전과 동일한 드라이버 버전 사용
        base_url = "https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing"
        download_url = f"{base_url}/{chrome_version}/win64/chromedriver-win64.zip"

        chrome_driver_path = os.path.join(os.getcwd(), "chromedriver.exe")

        # 3. 드라이버가 없거나 버전이 다른 경우 다운로드
        if not os.path.exists(chrome_driver_path):
            import urllib.request
            import zipfile

            logger.info(f"ChromeDriver 버전 {driver_version} 다운로드 중")
            zip_path = "chromedriver.zip"

            # 드라이버 zip 파일 다운로드
            urllib.request.urlretrieve(download_url, zip_path)

            # zip 파일 압축 해제
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                for file in zip_ref.namelist():
                    if file.endswith('chromedriver.exe'):
                        zip_ref.extract(file)
                        if os.path.exists('chromedriver-win64/chromedriver.exe'):
                            import shutil
                            shutil.move('chromedriver-win64/chromedriver.exe', 'chromedriver.exe')
                            shutil.rmtree('chromedriver-win64')

            # 임시 파일 삭제
            if os.path.exists(zip_path):
                os.remove(zip_path)

            logger.info("ChromeDriver 다운로드 완료")

        # 4. 옵션 설정
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument('--disable-infobars')
        options.add_argument('--start-maximized')
        options.add_argument('--disable-web-security')
        options.add_argument('--allow-running-insecure-content')
        options.add_argument('--log-level=3')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--enable-unsafe-swiftshader')
        options.add_argument('--disable-software-rasterizer')
        options.add_argument('--proxy-bypass-list=*')
        options.add_argument('--ignore-certificate-errors')

        # Windows 최적화를 위한 추가 옵션
        options.add_argument('--disable-extensions')
        options.add_argument('--disable-popup-blocking')
        options.add_argument('--disable-default-apps')
        options.add_argument('--disable-notifications')
        options.add_argument('--disable-background-timer-throttling')
        options.add_argument('--disable-backgrounding-occluded-windows')
        options.add_argument('--disable-renderer-backgrounding')
        options.add_argument('--disable-background-networking')
        options.add_argument('--disable-breakpad')
        options.add_argument('--disable-component-update')
        options.add_argument('--disable-domain-reliability')
        options.add_argument('--disable-sync')

        # 메모리 사용량 최적화 - 개선됨
        options.add_argument('--js-flags="--max_old_space_size=128"')
        options.add_argument('--disable-features=site-per-process')  # 프로세스 격리 해제로 메모리 사용량 감소
        options.add_argument('--memory-model=low')
        options.add_argument('--disable-hang-monitor')
        options.add_argument('--disable-translate')

        # 디스크 캐시 크기 제한 및 관리 - 개선됨
        options.add_argument('--disk-cache-size=10485760')  # 10MB로 제한 (더 작게 수정)
        options.add_argument('--media-cache-size=0')
        options.add_argument('--aggressive-cache-discard')

        # 캐시를 완전히 비활성화하여 디스크 사용량 방지 - 추가 옵션
        options.add_argument('--disable-application-cache')
        options.add_argument('--disable-cache')
        options.add_argument('--disable-offline-load-stale-cache')
        options.add_argument('--disable-http-cache')
        options.add_argument('--disable-clear-browsing-data-counters')

        # 더 효율적인 페이지 로딩
        options.page_load_strategy = 'eager'  # 'normal', 'eager', 'none' 중 선택

        # 임시 프로필 사용
        if use_temp_profile:
            profile_dir = create_temp_profile()
            options.add_argument(f'--user-data-dir={profile_dir}')

            # Default 디렉토리가 존재하는지 확인
            default_dir = os.path.join(profile_dir, "Default")
            if not os.path.exists(default_dir):
                os.makedirs(default_dir, exist_ok=True)

            # 프로필 디렉토리에 캐시 설정 추가
            preferences_path = os.path.join(default_dir, 'Preferences')
            with open(preferences_path, 'w') as f:
                import json
                preferences = {
                    "download": {
                        "default_directory": "",
                        "extensions_to_open": "",
                        "prompt_for_download": True
                    },
                    "profile": {
                        "default_content_settings": {
                            "cookies": 2,  # 쿠키 차단
                            "images": 2,  # 이미지 차단 (선택적)
                            "popups": 2  # 팝업 차단
                        },
                        "content_settings": {
                            "pattern_pairs": {
                                "*": {
                                    "storage": "block"  # 로컬 스토리지 차단
                                }
                            }
                        }
                    },
                    "net": {
                        "network_prediction_options": 2  # 네트워크 예측 비활성화
                    }
                }
                json.dump(preferences, f)
            logger.info(f"임시 Chrome 프로필 생성 및 캐시 설정 구성: {profile_dir}")

        # 디버그 모드가 아닐 때만 headless 모드 활성화
        if not debug:
            options.add_argument('--headless=new')  # 새로운 헤드리스 모드 사용
            logger.info("헤드리스 모드로 브라우저 실행")
        else:
            logger.info("디버그 모드로 브라우저 실행 (화면에 표시)")

        # 5. Service 객체 생성 및 드라이버 초기화
        service = ChromeService(chrome_driver_path)
        driver = webdriver.Chrome(service=service, options=options)

        # 페이지 로드 전략 설정 (성능 향상)
        driver.set_page_load_timeout(30)  # 30초 타임아웃
        driver.get("about:blank")
        logger.info("ChromeDriver 초기화 완료")
        return driver

    except Exception as e:
        detailed_error = f"드라이버 설정 실패: {str(e)}\n"
        detailed_error += f"Chrome 옵션: {options.arguments}\n"
        detailed_error += f"시스템: {sys.platform}\n"
        detailed_error += f"Python 버전: {sys.version}"
        logger.error(detailed_error)
        # 기존 드라이버 프로세스 정리
        kill_all_chrome_drivers()
        raise Exception(f"ChromeDriver 초기화 실패: {str(e)}")


def get_url_with_protocol(url):
    """URL에 프로토콜 추가 및 유효성 검사"""
    if not url.strip():  # 빈 URL 체크
        return None, "빈 URL이 제공됨"
    try:
        parsed_url = urlparse(url)
        if parsed_url.scheme:
            return url, None
        else:
            try:
                response = requests.get(f"https://{url}", timeout=5, verify=False)
                response.raise_for_status()
                return f"https://{url}", None
            except requests.exceptions.RequestException:
                return f"http://{url}", None
    except Exception as e:
        error_msg = f"유효하지 않은 URL 또는 IP 주소: {url}. 오류: {str(e)}"
        logger.error(error_msg)
        return None, error_msg


def get_log_filename():
    """로그 파일명 생성"""
    log_dir = os.path.join(os.getcwd(), "csv_logs")
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    return os.path.join(log_dir, f"로그_{datetime.now().strftime('%y%m%d%H')}.csv")


def cleanup_old_logs():
    """오래된 로그 파일 정리"""
    try:
        # 보관 기간 설정
        cutoff_date = datetime.now() - timedelta(days=LOG_RETENTION_DAYS)

        # CSV 로그 정리
        csv_log_dir = os.path.join(os.getcwd(), "csv_logs")
        if os.path.exists(csv_log_dir):

            for file in os.listdir(csv_log_dir):
                file_path = os.path.join(csv_log_dir, file)

                # 파일 크기 확인
                if os.path.getsize(file_path) > MAX_LOG_SIZE_MB * 1024 * 1024:
                    # 큰 파일은 백업 후 삭제
                    backup_path = file_path + ".bak"
                    try:
                        shutil.copy2(file_path, backup_path)
                        os.remove(file_path)
                        logger.info(f"큰 로그 파일 백업 및 삭제: {file_path}")
                    except Exception as e:
                        logger.error(f"큰 파일 처리 오류: {str(e)}")
                    continue

                # 파일 날짜 확인
                try:
                    file_date_str = file.split('_')[1].split('.')[0][:6]  # 'yymmddhh' 형식에서 'yymmdd' 추출
                    file_date = datetime.strptime(file_date_str, '%y%m%d')

                    if file_date < cutoff_date:
                        os.remove(file_path)
                        logger.info(f"오래된 로그 파일 삭제: {file}")
                except (ValueError, IndexError):
                    # 파일명 형식이 예상과 다른 경우
                    logger.warning(f"파일명 형식이 예상과 다릅니다: {file}")
                    continue

        # 앱 로그 정리
        app_log_dir = os.path.join(os.getcwd(), "logs")
        if os.path.exists(app_log_dir):
            for file in os.listdir(app_log_dir):
                file_path = os.path.join(app_log_dir, file)
                # 파일 수정 시간 기준 오래된 파일 삭제
                if os.path.getmtime(file_path) < cutoff_date.timestamp():
                    os.remove(file_path)
                    logger.info(f"오래된 앱 로그 파일 삭제: {file}")

        return True
    except Exception as e:
        logger.error(f"로그 정리 중 오류 발생: {str(e)}")
        return False


def check_system_resources():
    """시스템 리소스 확인 및 경고"""
    try:
        # 메모리 사용량 확인
        memory = psutil.virtual_memory()
        memory_percent = memory.percent

        # 디스크 사용량 확인
        disk = psutil.disk_usage('/')
        disk_percent = disk.percent

        # CPU 사용량 확인
        cpu_percent = psutil.cpu_percent(interval=0.5)

        # 메모리 사용량이 임계치를 초과할 경우
        if memory_percent > MAX_MEMORY_PERCENT:
            logger.warning(f"메모리 사용량 경고: {memory_percent}% (임계치: {MAX_MEMORY_PERCENT}%)")
            # 가비지 컬렉션 강제 실행
            gc.collect()
            # 로그 정리
            cleanup_old_logs()
            return False

        # 디스크 사용량이 90%를 초과할 경우
        if disk_percent > 90:
            logger.warning(f"디스크 사용량 경고: {disk_percent}% (임계치: 90%)")
            # 로그 정리
            cleanup_old_logs()
            return False

        # CPU 사용량이 95%를 초과할 경우
        if cpu_percent > 95:
            logger.warning(f"CPU 사용량 경고: {cpu_percent}% (임계치: 95%)")
            return False

        # 모든 리소스가 정상 범위 내
        logger.info(f"시스템 리소스 상태: 메모리 {memory_percent}%, 디스크 {disk_percent}%, CPU {cpu_percent}%")
        return True

    except Exception as e:
        logger.error(f"시스템 리소스 확인 중 오류 발생: {str(e)}")
        return True  # 오류 발생 시에도 계속 실행


class URLTestThread(QThread):
    """URL 테스트 스레드 - 개선된 버전"""
    log_signal = pyqtSignal(str)
    csv_log_signal = pyqtSignal(list)
    finished_signal = pyqtSignal()
    progress_signal = pyqtSignal(int)  # 진행 상황 표시용
    error_signal = pyqtSignal(str)  # 오류 신호

    def __init__(self, sites, interval, count, browser_option, logging_option, number_option, block_phrase,
                 console_logging_option, block_mode, debug_mode=False):
        super().__init__()
        self.sites = sites
        self.interval = interval
        self.count = count
        self.browser_option = browser_option
        self.logging_option = logging_option
        self.number_option = number_option
        self.block_phrase = block_phrase
        self.console_logging_option = console_logging_option
        self.block_mode = block_mode
        self.debug_mode = debug_mode
        self.running = True
        self.driver = None
        self.mutex = QMutex()
        self.wait_condition = QWaitCondition()
        self.shutdown_event = False
        self.restart_required = False
        self.memory_warning_sent = False
        self.restart_count = 0
        self.max_restarts = 5
        self.last_driver_restart = time.time()
        self.use_temp_profile = True  # 임시 프로필 사용 여부

        # 첫 번째 크롬 프로필 생성
        if self.use_temp_profile:
            self.current_profile = create_temp_profile()
        else:
            self.current_profile = None

        # 스레드 종료 시 자원 정리
        self.finished.connect(self.cleanup_resources)

    def run(self):
        """메인 스레드 실행 함수"""
        iteration = 0
        self.driver = None
        sites_count = len(self.sites)
        last_resource_check = time.time()

        try:
            # 브라우저 옵션이 "한 번만 열기"인 경우, 시작할 때 한 번만 브라우저 초기화
            if self.browser_option == 1:  # 한 번만 열기 옵션
                try:
                    self.driver = setup_driver(debug=self.debug_mode, use_temp_profile=self.use_temp_profile)
                    self.last_driver_restart = time.time()
                    self.log_signal.emit(f"[{datetime.now()}] 브라우저가 성공적으로 초기화되었습니다 (한 번만 열기 모드)")
                except Exception as e:
                    self.log_signal.emit(f"[{datetime.now()}] 초기 드라이버 설정 오류: {str(e)}")
                    self.error_signal.emit(f"브라우저 초기화 오류: {str(e)}")
                    return

            while self.running and (self.count == 0 or iteration < self.count):
                # 주기적으로 시스템 리소스 확인 (60초마다)
                if time.time() - last_resource_check > 60:
                    if not check_system_resources():
                        # 리소스 문제가 있을 경우 경고 로그
                        if not self.memory_warning_sent:
                            self.log_signal.emit(f"[{datetime.now()}] 경고: 시스템 리소스 부족. 가비지 컬렉션 및 로그 정리 수행.")
                            self.memory_warning_sent = True
                            # 드라이버 재시작 - 한 번만 열기 모드에서도 이 경우 재시작
                            self.safe_quit_driver()
                            self.driver = None
                            gc.collect()  # 강제 가비지 컬렉션
                    else:
                        self.memory_warning_sent = False
                    last_resource_check = time.time()

                # 주기적으로 로그 정리 (2시간마다)
                cleanup_old_logs()

                for site_idx, site in enumerate(self.sites):
                    if not self.running:
                        break

                    # 진행 상황 보고
                    progress = int((site_idx / sites_count) * 100)
                    self.progress_signal.emit(progress)

                    site_with_protocol, error_msg = get_url_with_protocol(site)
                    if error_msg:
                        self.log_signal.emit(f"[{datetime.now()}] 오류: {error_msg}")
                        self.csv_log_signal.emit([site, "오류", error_msg])
                        continue

                    # 주기적으로 드라이버 재시작 (메모리 누수 방지, 2시간마다) - 한 번만 열기 모드에서도 적용
                    current_time = time.time()
                    if self.driver is not None and current_time - self.last_driver_restart > 7200:  # 2시간 = 7200초
                        self.log_signal.emit(f"[{datetime.now()}] 정기 드라이버 재시작 (메모리 누수 방지)")
                        self.safe_quit_driver()
                        self.driver = None
                        gc.collect()  # 강제 가비지 컬렉션
                        self.last_driver_restart = current_time

                    # 브라우저가 실행 중인지 확인하고, 종료되었다면 재시작
                    if self.driver is not None:
                        try:
                            # 더 안정적인 브라우저 상태 확인 방법
                            # 단순히 current_url 확인 대신 실제 명령 실행
                            self.driver.execute_script("return document.readyState")

                            # 디버그 모드 변경 감지 - 실시간 반영
                            if hasattr(self.driver, 'options') and hasattr(self.driver.options, 'arguments'):
                                current_headless = '--headless=new' in self.driver.options.arguments
                                if self.debug_mode and current_headless:
                                    # 디버그 모드로 전환 필요
                                    self.log_signal.emit(f"[{datetime.now()}] 디버그 모드로 변경 감지, 브라우저 재시작")
                                    self.safe_quit_driver()
                                    self.driver = None
                                elif not self.debug_mode and not current_headless:
                                    # 헤드리스 모드로 전환 필요
                                    self.log_signal.emit(f"[{datetime.now()}] 헤드리스 모드로 변경 감지, 브라우저 재시작")
                                    self.safe_quit_driver()
                                    self.driver = None
                        except Exception as e:
                            # 실제로 브라우저가 응답하지 않는 경우만 재시작
                            self.log_signal.emit(f"[{datetime.now()}] 브라우저가 응답하지 않음, 재시작 시도: {str(e)}")
                            self.safe_quit_driver()
                            self.driver = None
                            time.sleep(1)  # 재시작 전 잠시 대기

                    # 브라우저가 없으면 새로 시작 (한 번만 열기 모드에서도 브라우저가 없으면 재시작)
                    if self.driver is None:
                        # 재시작 횟수 제한 (무한 루프 방지)
                        max_retries = 3
                        retry_count = 0
                        while self.driver is None and retry_count < max_retries:
                            try:
                                self.driver = setup_driver(debug=self.debug_mode,
                                                           use_temp_profile=self.use_temp_profile)
                                self.last_driver_restart = time.time()
                                self.log_signal.emit(
                                    f"[{datetime.now()}] 브라우저가 {'시작' if retry_count == 0 else '재시작'}되었습니다.")
                                break  # 성공하면 루프 탈출
                            except Exception as e:
                                retry_count += 1
                                self.log_signal.emit(
                                    f"[{datetime.now()}] 드라이버 설정 오류 ({retry_count}/{max_retries}): {str(e)}")
                                time.sleep(2 * retry_count)  # 재시도 간격을 점점 늘림

                        # 최대 재시도 횟수를 초과하면 이 URL 건너뛰기
                        if self.driver is None:
                            self.log_signal.emit(f"[{datetime.now()}] 최대 재시도 횟수 초과. 브라우저를 시작할 수 없습니다.")
                            continue

                    if self.number_option == 1:
                        url = f"{site_with_protocol}/{iteration + 1}"
                    else:
                        url = site_with_protocol

                    try:
                        self.driver.set_page_load_timeout(30)  # 페이지 로드 타임아웃 설정

                        # 캐시 정리를 위한 쿠키 및 세션 스토리지 삭제 (한 번만 열기 모드에서 중요)
                        if self.browser_option == 1 and site_idx > 0 and site_idx % 10 == 0:
                            try:
                                self.driver.delete_all_cookies()
                                self.driver.execute_script("window.sessionStorage.clear();")
                                self.driver.execute_script("window.localStorage.clear();")
                            except Exception as e:
                                self.log_signal.emit(f"[{datetime.now()}] 캐시 정리 오류: {str(e)}")

                        self.driver.get(url)

                        # 페이지 로드 완료 대기
                        WebDriverWait(self.driver, 30).until(
                            EC.presence_of_element_located((By.TAG_NAME, "body"))
                        )

                        # 메모리 사용량 확인 및 정리
                        self.check_and_clean_memory()

                        # 스레드 안전한 대기
                        self.safe_sleep(self.interval)

                        if not self.running:
                            break

                        if self.block_mode == 0:  # 인라인 모드
                            iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                            if len(iframes) > 0:
                                iframe_src = iframes[0].get_attribute('src')
                                decoded_src = unquote(iframe_src) if iframe_src else ""
                                if self.block_phrase in decoded_src:
                                    log_message = f"[{datetime.now()}] URL: {url} - 차단됨 (인라인)"
                                    if self.console_logging_option == 0 or self.console_logging_option == 3:
                                        self.log_signal.emit(log_message)
                                    # 차단된 경우만 또는 모두 로그일 때만 CSV 로깅
                                    if self.console_logging_option == 0 or self.console_logging_option == 3:
                                        self.csv_log_signal.emit([url, "차단됨 (인라인)", ""])
                                else:
                                    log_message = f"[{datetime.now()}] URL: {url} - 차단되지 않음 (인라인)"
                                    if self.console_logging_option == 1 or self.console_logging_option == 3:
                                        self.log_signal.emit(log_message)
                                    # 차단되지 않은 경우만 또는 모두 로그일 때만 CSV 로깅
                                    if self.console_logging_option == 1 or self.console_logging_option == 3:
                                        self.csv_log_signal.emit([url, "차단되지 않음 (인라인)", ""])
                            else:
                                log_message = f"[{datetime.now()}] URL: {url} - 차단되지 않음 (인라인)"
                                if self.console_logging_option == 1 or self.console_logging_option == 3:
                                    self.log_signal.emit(log_message)
                                # 차단되지 않은 경우만 또는 모두 로그일 때만 CSV 로깅
                                if self.console_logging_option == 1 or self.console_logging_option == 3:
                                    self.csv_log_signal.emit([url, "차단되지 않음 (인라인)", ""])

                    except TimeoutException:
                        log_message = f"[{datetime.now()}] URL: {url} - 30초 동안 로딩 없음"
                        self.log_signal.emit(log_message)
                        self.csv_log_signal.emit([url, "30초 동안 로딩 없음", ""])
                        continue  # 다음 URL로 넘어감

                    except Exception as e:
                        if self.block_mode == 0:
                            log_message = f"[{datetime.now()}] URL: {url} - 접속 안됨 (인라인) - {str(e)}"
                            self.csv_log_signal.emit([url, "접속 안됨 (인라인)", str(e)])
                        else:
                            log_message = f"[{datetime.now()}] URL: {url} - 접속 안됨 (미러링) - {str(e)}"
                            self.csv_log_signal.emit([url, "접속 안됨 (미러링)", str(e)])

                        self.log_signal.emit(log_message)

                        # 오류 발생 시 "매번 열고 닫기" 모드에서만 브라우저 재시작
                        if self.browser_option == 0:
                            self.safe_quit_driver()
                            self.driver = None
                        else:
                            # "한 번만 열기" 모드에서는 페이지만 초기화
                            try:
                                self.driver.get("about:blank")
                            except:
                                # 브라우저에 문제가 생겼다면 재시작
                                self.safe_quit_driver()
                                self.driver = None

                    # "매번 열고 닫기" 모드인 경우에만 브라우저 종료
                    if self.browser_option == 0:
                        self.safe_quit_driver()
                        self.driver = None

                if not self.running:
                    break

                iteration += 1

                # 진행 상황 100% 표시
                if iteration >= self.count and self.count > 0:
                    self.progress_signal.emit(100)

                # 메모리 사용량 확인 및 로그 정리
                self.check_and_clean_memory()

                # 중간 가비지 컬렉션 수행
                if iteration % 10 == 0:  # 10회 반복마다
                    gc.collect()

        except Exception as e:
            logger.error(f"스레드 실행 중 예외 발생: {str(e)}")
            self.error_signal.emit(f"스레드 오류: {str(e)}")
        finally:
            self.safe_quit_driver()
            self.finished_signal.emit()

    def check_and_clean_memory(self):
        """메모리 사용량 확인 및 정리"""
        try:
            # 현재 프로세스의 메모리 사용량 확인
            process = psutil.Process(os.getpid())
            memory_info = process.memory_info()
            memory_mb = memory_info.rss / (1024 * 1024)  # MB 단위

            # 시스템 메모리 사용량 확인
            system_memory = psutil.virtual_memory()
            system_memory_percent = system_memory.percent

            # 로그에 메모리 사용량 기록 (30분마다)
            if time.time() % 1800 < 5:  # 30분(1800초)마다 5초 이내
                logger.info(f"메모리 사용량: 프로세스 {memory_mb:.2f} MB, 시스템 {system_memory_percent}%")

            # 메모리 사용량이 높을 경우 정리 작업
            if memory_mb > 500 or system_memory_percent > MAX_MEMORY_PERCENT:
                logger.warning(f"높은 메모리 사용량 감지: {memory_mb:.2f} MB / {system_memory_percent}%. 정리 수행")

                # 가비지 컬렉션 실행
                gc.collect()

                # 브라우저가 열려있으면 재시작
                if self.driver is not None and memory_mb > 800:  # 800 MB 이상이면 브라우저 재시작
                    logger.warning("높은 메모리 사용량으로 브라우저 재시작")
                    self.safe_quit_driver()
                    self.driver = None

                # 로그 정리
                cleanup_old_logs()
        except Exception as e:
            logger.error(f"메모리 확인 중 오류: {str(e)}")

    def safe_sleep(self, seconds):
        """스레드 안전한 대기 (중단 가능)"""
        if seconds <= 0:
            return

        self.mutex.lock()
        try:
            if self.running:
                self.wait_condition.wait(self.mutex, seconds * 1000)
        finally:
            self.mutex.unlock()

    def safe_quit_driver(self):
        """안전하게 드라이버 종료 - 더 강화된 버전"""
        if self.driver is not None:
            try:
                # 전체 과정에 타임아웃 설정 (더 안전한 종료를 위해)
                quit_success = False

                # 1. 먼저 모든 창 닫기 시도
                try:
                    # 현재 열린 창 핸들 확인
                    all_handles = self.driver.window_handles
                    # 열린 창이 여러 개인 경우 처리
                    if len(all_handles) > 1:
                        current_handle = self.driver.current_window_handle
                        for handle in all_handles:
                            if handle != current_handle:
                                self.driver.switch_to.window(handle)
                                self.driver.close()
                        # 원래 창으로 돌아가기
                        self.driver.switch_to.window(current_handle)
                except Exception as e:
                    self.log_signal.emit(f"[{datetime.now()}] 창 닫기 오류 (무시됨): {str(e)}")

                # 2. 빈 페이지로 이동하여 리소스 정리
                try:
                    self.driver.get("about:blank")
                    time.sleep(0.5)  # 페이지 로드 대기
                except Exception as e:
                    self.log_signal.emit(f"[{datetime.now()}] 빈 페이지 로드 오류 (무시됨): {str(e)}")

                # 3. 드라이버 종료 시도 (타임아웃 설정)
                try:
                    import threading
                    quit_event = threading.Event()

                    def quit_driver():
                        try:
                            self.driver.quit()
                            quit_event.set()
                        except Exception as e:
                            self.log_signal.emit(f"[{datetime.now()}] 드라이버 종료 스레드 오류: {str(e)}")

                    quit_thread = threading.Thread(target=quit_driver)
                    quit_thread.daemon = True
                    quit_thread.start()

                    # 5초 대기 후 타임아웃 처리
                    quit_success = quit_event.wait(5)
                except Exception as e:
                    self.log_signal.emit(f"[{datetime.now()}] 드라이버 종료 타임아웃 처리 오류: {str(e)}")

                if quit_success:
                    self.log_signal.emit(f"[{datetime.now()}] 브라우저가 정상적으로 종료되었습니다.")
                else:
                    self.log_signal.emit(f"[{datetime.now()}] 브라우저 정상 종료 실패, 강제 종료 시도 중...")
                    # 4. 강제 종료 시도
                    try:
                        # 현재 실행 중인 모든 chromedriver 프로세스 찾기
                        for proc in psutil.process_iter(['pid', 'name']):
                            try:
                                if 'chromedriver' in proc.info['name'].lower():
                                    psutil.Process(proc.info['pid']).terminate()
                                    self.log_signal.emit(f"[{datetime.now()}] ChromeDriver 프로세스 종료: {proc.info['pid']}")
                            except:
                                pass

                        # 관련 Chrome 프로세스 정리 (선택적)
                        if self.driver is not None:
                            try:
                                driver_pid = self.driver.service.process.pid
                                parent = psutil.Process(driver_pid)
                                children = parent.children(recursive=True)
                                for child in children:
                                    try:
                                        child.terminate()
                                    except:
                                        pass
                            except:
                                pass
                    except Exception as e:
                        self.log_signal.emit(f"[{datetime.now()}] 프로세스 강제 종료 오류: {str(e)}")
            except Exception as e:
                self.log_signal.emit(f"[{datetime.now()}] 브라우저 종료 중 오류 발생: {str(e)}")
            finally:
                self.driver = None
                gc.collect()  # 메모리 정리
                # 연결 풀 정리를 위한 추가 대기
                time.sleep(1)

    def stop(self):
        """스레드 중지 (더 빠르고 안정적으로)"""
        self.running = False

        # 대기 중인 스레드 깨우기
        self.mutex.lock()
        self.wait_condition.wakeAll()
        self.mutex.unlock()

        # 드라이버 안전하게 종료
        self.safe_quit_driver()

        # 크롬 드라이버 프로세스 강제 종료
        kill_all_chrome_drivers()

        # QThread 종료
        self.quit()
        if not self.wait(3000):  # 3초 대기
            logger.warning("스레드가 정상적으로 종료되지 않아 강제 종료합니다.")
            self.terminate()
            self.wait(1000)

    def cleanup_resources(self):
        """스레드 종료 시 자원 정리"""
        logger.info("스레드 자원 정리 중...")
        self.safe_quit_driver()

    def update_debug_mode(self, debug_mode):
        """디버그 모드 설정 업데이트"""
        if self.debug_mode != debug_mode:
            self.debug_mode = debug_mode
            self.log_signal.emit(f"[{datetime.now()}] 디버그 모드 변경: {debug_mode}")

            # 브라우저가 실행 중인 경우 재시작
            if self.driver is not None:
                self.log_signal.emit(f"[{datetime.now()}] 디버그 모드 변경으로 브라우저 재시작")
                self.safe_quit_driver()
                self.driver = None


class SystemMonitor(QThread):
    """시스템 리소스 모니터링 스레드"""
    resource_signal = pyqtSignal(dict)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.running = True

    def run(self):
        while self.running:
            try:
                # 시스템 리소스 정보 수집
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                cpu_percent = psutil.cpu_percent(interval=1)

                # 프로세스 정보 수집
                process = psutil.Process(os.getpid())
                process_memory = process.memory_info().rss / (1024 * 1024)  # MB

                # 시그널 발생
                self.resource_signal.emit({
                    'memory_percent': memory.percent,
                    'disk_percent': disk.percent,
                    'cpu_percent': cpu_percent,
                    'process_memory': process_memory
                })

                # 10초마다 업데이트
                for _ in range(10):
                    if not self.running:
                        break
                    time.sleep(1)

            except Exception as e:
                logger.error(f"시스템 모니터링 오류: {str(e)}")
                time.sleep(10)  # 오류 발생 시 10초 대기

    def stop(self):
        self.running = False
        self.quit()
        if not self.wait(3000):
            self.terminate()
            self.wait(1000)


class URLTestApp(QWidget):
    """URL 테스트 애플리케이션 - 개선된 버전"""

    def __init__(self):
        super().__init__()
        # UI 초기화 전에 시스템 상태 레이블 생성
        self.system_status_label = QLabel("시스템 상태: 준비")
        self.system_status_label.setStyleSheet("color: green;")

        self.initUI()
        self.log_filename = get_log_filename()
        self.log_count = 1
        self.test_threads = []
        self.csv_file_path = None
        self.csv_encoding = 'utf-8-sig'
        self.tray_icon = None

        # 윈도우 최적화 설정
        set_process_priority_high()
        register_exit_handlers()

        # 시스템 모니터 스레드 시작
        self.system_monitor = SystemMonitor(self)
        self.system_monitor.resource_signal.connect(self.update_resource_status)
        self.system_monitor.start()

        # 정기적으로 메모리 관리 수행
        self.cleanup_timer = QTimer(self)
        self.cleanup_timer.timeout.connect(self.perform_memory_cleanup)
        self.cleanup_timer.start(30000)  # 30초마다 실행

        # UI 응답성을 위한 타이머 추가
        self.ui_update_timer = QTimer(self)
        self.ui_update_timer.timeout.connect(self.process_ui_events)
        self.ui_update_timer.start(100)  # 100ms마다 UI 이벤트 처리

        # 오래된 로그 정리 타이머
        self.log_cleanup_timer = QTimer(self)
        self.log_cleanup_timer.timeout.connect(cleanup_old_logs)
        self.log_cleanup_timer.start(3600000)  # 1시간마다 실행

        # 초기 로그 정리 수행
        cleanup_old_logs()

        # 시스템 트레이 아이콘 설정 (필요 시)
        self.setup_tray_icon()

        # 주기적으로 메모리 사용량 확인하고 로그에 기록
        self.memory_check_timer = QTimer(self)
        self.memory_check_timer.timeout.connect(self.log_memory_usage)
        self.memory_check_timer.start(300000)  # 5분마다 실행

        # 프로그램 종료 시 정리 작업
        QApplication.instance().aboutToQuit.connect(self.on_application_exit)

    def split_urls(self, urls, chunks):
        """URLs를 지정된 chunks 수만큼 분할 - 최적화됨"""
        if not urls:
            return []

        n = len(urls)
        chunks = min(chunks, n)

        # 최적화된 URL 분배 (CPU 코어 수에 따라 조정)
        available_cores = min(os.cpu_count() or 4, 8)  # 최대 8개 코어 사용
        optimal_chunks = min(chunks, available_cores)

        # URL 분할
        result = [[] for _ in range(optimal_chunks)]
        for i, url in enumerate(urls):
            result[i % optimal_chunks].append(url)

        return result

    def setup_tray_icon(self):
        """시스템 트레이 아이콘 설정"""
        try:
            if QSystemTrayIcon.isSystemTrayAvailable():
                # 기본 아이콘 사용
                icon = QIcon("icon.png")  # 아이콘 파일이 없으면 기본 아이콘 사용

                # 트레이 아이콘 메뉴 생성
                tray_menu = QMenu()
                show_action = tray_menu.addAction("앱 보기")
                show_action.triggered.connect(self.show)

                exit_action = tray_menu.addAction("종료")
                exit_action.triggered.connect(QApplication.quit)

                # 트레이 아이콘 생성
                self.tray_icon = QSystemTrayIcon(self)
                self.tray_icon.setIcon(icon)
                self.tray_icon.setToolTip("URL 테스트 애플리케이션")
                self.tray_icon.setContextMenu(tray_menu)
                self.tray_icon.activated.connect(self.tray_icon_activated)

                # 트레이 아이콘 표시
                self.tray_icon.show()

                logger.info("시스템 트레이 아이콘 설정 완료")
        except Exception as e:
            logger.error(f"시스템 트레이 아이콘 설정 오류: {str(e)}")

    def tray_icon_activated(self, reason):
        """트레이 아이콘 클릭 이벤트"""
        if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.show()
            self.activateWindow()

    def update_resource_status(self, resources):
        """시스템 리소스 상태 업데이트"""
        memory_percent = resources['memory_percent']
        disk_percent = resources['disk_percent']
        cpu_percent = resources['cpu_percent']
        process_memory = resources['process_memory']

        status_text = f"메모리: {memory_percent:.1f}% | 디스크: {disk_percent:.1f}% | CPU: {cpu_percent:.1f}% | 앱: {process_memory:.1f}MB"

        # 상태에 따라 색상 변경
        if memory_percent > 90 or disk_percent > 90 or cpu_percent > 90:
            self.system_status_label.setStyleSheet("color: red; font-weight: bold;")
        elif memory_percent > 70 or disk_percent > 70 or cpu_percent > 70:
            self.system_status_label.setStyleSheet("color: orange;")
        else:
            self.system_status_label.setStyleSheet("color: green;")

        self.system_status_label.setText(status_text)

    def log_memory_usage(self):
        """메모리 사용량 로그에 기록"""
        try:
            # 현재 프로세스의 메모리 사용량 확인
            process = psutil.Process(os.getpid())
            memory_info = process.memory_info()
            memory_mb = memory_info.rss / (1024 * 1024)  # MB 단위

            # 시스템 메모리 사용량 확인
            system_memory = psutil.virtual_memory()
            system_memory_percent = system_memory.percent

            # 디스크 사용량 확인
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent

            log_message = (f"[{datetime.now()}] 시스템 상태 - "
                           f"앱 메모리: {memory_mb:.2f}MB, "
                           f"시스템 메모리: {system_memory_percent}%, "
                           f"디스크: {disk_percent}%")

            self.log_message(log_message)
            logger.info(log_message)

            # 메모리 사용량이 높을 경우 경고 및 정리
            if memory_mb > 800 or system_memory_percent > 90:
                warning_msg = f"[{datetime.now()}] 경고: 높은 메모리 사용량 감지. 정리 작업 수행..."
                self.log_message(warning_msg)
                self.perform_memory_cleanup()
                cleanup_old_logs()
        except Exception as e:
            logger.error(f"메모리 사용량 로깅 오류: {str(e)}")

    def initUI(self):
        """UI 초기화"""
        self.setWindowTitle('URL_Block_Check')
        self.setGeometry(100, 100, 800, 600)
        self.setStyleSheet("""
            QWidget {
                background-color: #2e2e2e;
                color: white;
            }
            QLabel {
                font-size: 14px;
                font-family: Arial, sans-serif;
            }
            QLineEdit, QSpinBox, QComboBox {
                font-size: 14px;
                font-family: Arial, sans-serif;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 5px;
                background-color: #444;
                color: white;
            }
            QPushButton {
                font-size: 14px;
                font-family: Arial, sans-serif;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 5px;
                color: white;
            }
            QTextEdit {
                font-size: 14px;
                font-family: Arial, sans-serif;
                background-color: #1e1e1e;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 10px;
                color: white;
            }
            QProgressBar {
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                background-color: #444;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                width: 10px;
                margin: 0.5px;
            }
        """)

        layout = QVBoxLayout()
        form_layout = QGridLayout()
        form_layout.setSpacing(10)  # 입력 필드 간의 간격 설정

        self.site_checkbox = QCheckBox("사이트")
        self.site_checkbox.setChecked(True)
        self.site_input = QLineEdit()
        self.site_input.setPlaceholderText("예: example1.com,example2.com,example3.com")
        self.site_input.setText("soosantest.com")

        self.csv_checkbox = QCheckBox("CSV 파일")
        self.csv_file_input = QLineEdit()
        self.csv_file_input.setReadOnly(True)
        self.csv_file_button = QPushButton("파일 선택")
        self.csv_file_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.csv_file_button.clicked.connect(self.select_csv_file)

        self.interval_label = QLabel("간격 (초):")
        self.interval_input = QSpinBox()
        self.interval_input.setValue(1)
        self.interval_input.setToolTip("각 테스트 사이의 시간 간격을 설정합니다.")

        self.count_label = QLabel("반복 횟수 (0은 무한 반복):")
        self.count_input = QSpinBox()
        self.count_input.setRange(0, 65535)
        self.count_input.setValue(1)
        self.count_input.setToolTip("테스트를 반복할 횟수를 설정합니다. 0으로 설정하면 무한 반복됩니다.")

        self.browser_option_label = QLabel("브라우저 옵션:")
        self.browser_option_input = QComboBox()
        self.browser_option_input.addItems(["매번 열고 닫기", "한 번만 열기"])
        self.browser_option_input.setToolTip("각 테스트마다 브라우저를 열고 닫을지, 한 번만 열고 계속 사용할지 선택합니다.")

        self.logging_option_label = QLabel("로그 옵션:")
        self.logging_option_input = QComboBox()
        self.logging_option_input.addItems(["로그 비활성화", "로그 활성화"])
        self.logging_option_input.setToolTip("테스트 결과를 로그 파일에 기록할지 선택합니다.")

        self.number_option_label = QLabel("숫자 옵션:")
        self.number_option_input = QComboBox()
        self.number_option_input.addItems(["사용 안 함", "사용"])
        self.number_option_input.setToolTip("각 테스트 반복 시 URL 경로에 숫자를 추가할지 선택합니다.")

        self.block_phrase_label = QLabel("차단 문구:")
        self.block_phrase_input = QLineEdit()
        self.block_phrase_input.setPlaceholderText("예: QA/DB_Block_Test")
        self.block_phrase_input.setText("QA/DB_Block_Test")
        self.block_phrase_input.setToolTip("iframe URL에 차단 여부를 확인할 문구를 입력합니다.")

        self.console_logging_label = QLabel("콘솔 로그 옵션:")
        self.console_logging_input = QComboBox()
        self.console_logging_input.addItems(["차단된 경우만", "차단되지 않은 경우만", "로그 없음", "모두 로그"])
        self.console_logging_input.setToolTip("콘솔에 어떤 로그를 표시할지 선택합니다.")

        self.block_mode_label = QLabel("차단 확인 모드:")
        self.block_mode_input = QComboBox()
        self.block_mode_input.addItems(["인라인", "미러링"])
        self.block_mode_input.setToolTip("차단 확인 모드를 선택합니다.")

        # 브라우저 병렬 처리 옵션
        self.parallel_label = QLabel("병렬 처리 개수:")
        self.parallel_input = QSpinBox()
        self.parallel_input.setRange(1, 5)  # 최대 5개 쓰레드로 제한 (윈도우 성능 고려)
        self.parallel_input.setValue(1)
        self.parallel_input.setToolTip("동시에 실행할 브라우저 개수를 설정합니다.")

        # 디버그 모드 옵션 추가
        self.debug_mode_checkbox = QCheckBox("디버그 모드 (브라우저 표시)")
        self.debug_mode_checkbox.setChecked(False)
        self.debug_mode_checkbox.setToolTip("체크하면 브라우저가 화면에 표시됩니다. 테스트 디버깅용.")

        # 메모리 관리 옵션 추가
        self.use_temp_profile_checkbox = QCheckBox("임시 프로필 사용 (메모리 누수 방지)")
        self.use_temp_profile_checkbox.setChecked(True)
        self.use_temp_profile_checkbox.setToolTip("각 세션에 임시 Chrome 프로필을 사용하여 캐시 및 메모리 누수를 방지합니다.")

        # 프로그레스 바 추가
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("%p%")

        self.start_button = QPushButton("시작")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.start_button.clicked.connect(self.toggle_test)

        self.clear_button = QPushButton("로그 지우기")
        self.clear_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.clear_button.clicked.connect(self.clear_log)

        # 강제 종료 버튼 추가
        self.force_stop_button = QPushButton("강제 종료")
        self.force_stop_button.setStyleSheet("""
            QPushButton {
                background-color: #d32f2f;
                color: white;
            }
            QPushButton:hover {
                background-color: #b71c1c;
            }
        """)
        self.force_stop_button.clicked.connect(self.force_stop_test)
        self.force_stop_button.setToolTip("모든 Chrome 및 ChromeDriver 프로세스를 강제 종료합니다.")

        # 메모리 정리 버튼 추가
        self.cleanup_button = QPushButton("메모리 정리")
        self.cleanup_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        self.cleanup_button.clicked.connect(self.manual_memory_cleanup)
        self.cleanup_button.setToolTip("가비지 컬렉션을 실행하고 오래된 로그 파일을 정리합니다.")

        self.output = QTextEdit()
        self.output.setReadOnly(True)

        # UI 요소의 최소 너비 설정
        min_width = 300
        self.site_input.setMinimumWidth(min_width)
        self.csv_file_input.setMinimumWidth(min_width)
        self.interval_input.setMinimumWidth(min_width)
        self.count_input.setMinimumWidth(min_width)
        self.browser_option_input.setMinimumWidth(min_width)
        self.logging_option_input.setMinimumWidth(min_width)
        self.number_option_input.setMinimumWidth(min_width)
        self.block_phrase_input.setMinimumWidth(min_width)
        self.console_logging_input.setMinimumWidth(min_width)
        self.block_mode_input.setMinimumWidth(min_width)

        form_layout.addWidget(self.site_checkbox, 0, 0)
        form_layout.addWidget(self.site_input, 0, 1, 1, 3)
        form_layout.addWidget(self.csv_checkbox, 1, 0)
        form_layout.addWidget(self.csv_file_input, 1, 1, 1, 2)
        form_layout.addWidget(self.csv_file_button, 1, 3)
        form_layout.addWidget(self.interval_label, 2, 0)
        form_layout.addWidget(self.interval_input, 2, 1, 1, 3)
        form_layout.addWidget(self.count_label, 3, 0)
        form_layout.addWidget(self.count_input, 3, 1, 1, 3)
        form_layout.addWidget(self.browser_option_label, 4, 0)
        form_layout.addWidget(self.browser_option_input, 4, 1, 1, 3)
        form_layout.addWidget(self.logging_option_label, 5, 0)
        form_layout.addWidget(self.logging_option_input, 5, 1, 1, 3)
        form_layout.addWidget(self.number_option_label, 6, 0)
        form_layout.addWidget(self.number_option_input, 6, 1, 1, 3)
        form_layout.addWidget(self.block_phrase_label, 7, 0)
        form_layout.addWidget(self.block_phrase_input, 7, 1, 1, 3)
        form_layout.addWidget(self.console_logging_label, 8, 0)
        form_layout.addWidget(self.console_logging_input, 8, 1, 1, 3)
        form_layout.addWidget(self.block_mode_label, 9, 0)
        form_layout.addWidget(self.block_mode_input, 9, 1, 1, 3)
        form_layout.addWidget(self.parallel_label, 10, 0)
        form_layout.addWidget(self.parallel_input, 10, 1, 1, 3)
        form_layout.addWidget(self.debug_mode_checkbox, 11, 0, 1, 4)
        form_layout.addWidget(self.use_temp_profile_checkbox, 12, 0, 1, 4)
        form_layout.addWidget(self.system_status_label, 13, 0, 1, 4)
        form_layout.addWidget(self.progress_bar, 14, 0, 1, 4)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.start_button)
        button_layout.addWidget(self.clear_button)
        button_layout.addWidget(self.cleanup_button)
        button_layout.addWidget(self.force_stop_button)

        # 디버그 모드 체크박스 상태 변경 이벤트 연결
        self.debug_mode_checkbox.stateChanged.connect(self.update_debug_mode)

        layout.addLayout(form_layout)
        layout.addLayout(button_layout)
        layout.addWidget(self.output)
        self.setLayout(layout)

    def select_csv_file(self):
        """CSV 파일 선택 - 개선됨"""
        try:
            file_dialog = QFileDialog()
            file_path, _ = file_dialog.getOpenFileName(self, "CSV 파일 선택", "", "CSV Files (*.csv)")
            if not file_path:
                return

            # 파일 크기 확인
            file_size = os.path.getsize(file_path)
            if file_size > 10 * 1024 * 1024:  # 10MB 이상
                reply = QMessageBox.question(
                    self, '대용량 파일 경고',
                    "10MB가 넘는 대용량 CSV 파일입니다. 처리하는데 시간이 오래 걸릴 수 있습니다. 계속하시겠습니까?",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No
                )
                if reply == QMessageBox.No:
                    return

            # 샘플링하여 인코딩 감지 - 대용량 파일 처리 최적화
            encoding = self.detect_csv_encoding(file_path)
            if not encoding:
                QMessageBox.critical(self, "오류", "CSV 파일 인코딩을 감지할 수 없습니다.")
                return

            # 헤더만 읽어 확인
            with open(file_path, 'r', encoding=encoding) as f:
                reader = csv.reader(f)
                header = next(reader, None)
                if not header:
                    QMessageBox.critical(self, "오류", "CSV 파일에 헤더가 없거나 빈 파일입니다.")
                    return

                # 미리보기 표시
                preview_rows = []
                for _ in range(5):  # 5개 행만 미리보기
                    row = next(reader, None)
                    if row:
                        preview_rows.append(row)
                    else:
                        break

            # CSV 파일 저장
            self.csv_file_path = file_path
            self.csv_file_input.setText(file_path)
            self.csv_encoding = encoding

            # 미리보기 메시지
            preview = f"CSV 파일이 로드되었습니다. 인코딩: {encoding}\n"
            preview += f"헤더: {', '.join(header)}\n"
            preview += f"{len(preview_rows)}개 행 미리보기: {preview_rows}"
            self.log_message(preview)

        except Exception as e:
            self.log_message(f"CSV 파일 로드 오류: {str(e)}")
            QMessageBox.critical(self, "오류", f"CSV 파일을 읽을 수 없습니다: {str(e)}")

    def detect_csv_encoding(self, file_path):
        """CSV 파일 인코딩 감지 - 최적화됨"""
        encodings = ['utf-8-sig', 'utf-8', 'cp949', 'euc-kr']

        # 파일의 처음 4KB만 읽어 인코딩 탐지
        sample_size = min(os.path.getsize(file_path), 4096)

        with open(file_path, 'rb') as f:
            raw_data = f.read(sample_size)

        for enc in encodings:
            try:
                raw_data.decode(enc)
                return enc
            except UnicodeDecodeError:
                continue

        return None

    def log_message(self, message):
        """UI에 로그 메시지 추가"""
        self.output.append(message)
        # 자동 스크롤
        self.output.verticalScrollBar().setValue(self.output.verticalScrollBar().maximum())
        # 즉시 UI 업데이트
        QApplication.processEvents()

    def clear_log(self):
        """로그 창 지우기"""
        self.output.clear()

    def log_to_csv(self, log_data):
        """CSV 파일에 로그 기록"""
        try:
            if self.logging_option_input.currentIndex() == 1:  # 로그 활성화
                with open(self.log_filename, 'a', newline='', encoding='utf-8') as file:
                    writer = csv.writer(file)
                    writer.writerow([self.log_count] + log_data)
                self.log_count += 1

                # 로그 파일 크기 확인
                if os.path.getsize(self.log_filename) > MAX_LOG_SIZE_MB * 1024 * 1024:
                    # 새 로그 파일 생성
                    self.log_filename = get_log_filename()
                    self.log_count = 1
                    self.log_message(f"로그 파일 크기 제한 도달. 새 로그 파일 생성: {self.log_filename}")
        except Exception as e:
            logger.error(f"CSV 로깅 오류: {str(e)}")
            # 최신 로그 파일을 다시 생성
            self.log_filename = get_log_filename()

    def update_debug_mode(self, state):
        """디버그 모드 상태 변경 처리 - 개선됨"""
        debug_mode = state == Qt.Checked

        # 이미 실행 중인 스레드가 있는 경우
        if self.test_threads and any(thread.isRunning() for thread in self.test_threads):
            # 사용자에게 확인 메시지 표시
            reply = QMessageBox.question(
                self, '디버그 모드 변경 확인',
                "디버그 모드 변경으로 인해 실행 중인 모든 브라우저가 재시작됩니다. 계속하시겠습니까?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                self.log_message(f"[{datetime.now()}] 디버그 모드 {'활성화됨' if debug_mode else '비활성화됨'}")

                # 모든 테스트 스레드에 대해 순차적으로 처리
                for thread in self.test_threads:
                    if thread.isRunning():
                        # 먼저 기존 드라이버 완전히 종료
                        if thread.driver is not None:
                            self.log_message(f"[{datetime.now()}] 디버그 모드 변경 준비: 기존 브라우저 종료 중...")
                            thread.safe_quit_driver()
                            thread.driver = None

                        # 가비지 컬렉션으로 메모리 정리
                        gc.collect()

                        # 잠시 대기하여 리소스 정리 시간 확보 (중요!)
                        time.sleep(2)

                        # 이제 디버그 모드 설정 업데이트
                        thread.debug_mode = debug_mode

                        # 자원 부족 확인 및 정리
                        if not check_system_resources():
                            self.log_message(f"[{datetime.now()}] 시스템 리소스 부족. 추가 정리 작업 수행...")
                            thread.check_and_clean_memory()
                            cleanup_old_logs()
                            time.sleep(1)

                # 크롬 드라이버 프로세스 정리 (추가)
                kill_all_chrome_drivers()
                time.sleep(1)  # 프로세스 종료 대기

                self.log_message(f"[{datetime.now()}] 디버그 모드 변경 완료. 브라우저는 다음 요청 시 재시작됩니다.")
            else:
                # 사용자가 취소한 경우 체크박스 상태 되돌림 (신호 차단 필요)
                self.debug_mode_checkbox.blockSignals(True)
                self.debug_mode_checkbox.setChecked(not debug_mode)
                self.debug_mode_checkbox.blockSignals(False)
                self.log_message(f"[{datetime.now()}] 디버그 모드 변경이 취소되었습니다.")
        else:
            # 실행 중인 스레드가 없는 경우, 설정만 변경
            self.log_message(f"[{datetime.now()}] 디버그 모드 {'활성화됨' if debug_mode else '비활성화됨'}")

    def toggle_test(self):
        """테스트 시작/중지 토글"""
        if not self.test_threads or all(not thread.isRunning() for thread in self.test_threads):
            self.start_test()
        else:
            self.stop_test()

    def manual_memory_cleanup(self):
        """수동 메모리 정리"""
        try:
            self.log_message(f"[{datetime.now()}] 수동 메모리 정리 시작...")

            # 가비지 컬렉션 강제 실행
            gc.collect()

            # 오래된 로그 파일 정리
            cleanup_old_logs()

            # Chrome 임시 프로필 정리
            cleanup_temp_profiles()

            # 메모리 통계 출력
            process = psutil.Process(os.getpid())
            memory_before = process.memory_info().rss / (1024 * 1024)

            # 시스템 메모리 캐시 정리 시도 (Windows)
            if sys.platform == 'win32':
                try:
                    import ctypes
                    ctypes.windll.kernel32.SetProcessWorkingSetSize(-1, -1)
                except Exception as e:
                    logger.error(f"시스템 메모리 캐시 정리 오류: {str(e)}")

            # 정리 후 메모리 확인
            memory_after = process.memory_info().rss / (1024 * 1024)
            memory_freed = max(0, memory_before - memory_after)

            self.log_message(f"[{datetime.now()}] 메모리 정리 완료. 확보한 메모리: {memory_freed:.2f} MB")
            self.log_message(f"[{datetime.now()}] 현재 메모리 사용량: {memory_after:.2f} MB")

            return True
        except Exception as e:
            self.log_message(f"[{datetime.now()}] 메모리 정리 중 오류 발생: {str(e)}")
            return False

    def start_test(self):
        """테스트 시작"""
        sites = []
        if self.site_checkbox.isChecked():
            sites = [site.strip() for site in self.site_input.text().split(",") if site.strip()]

        # CSV 파일에서 URL 정보 읽어오기
        if self.csv_checkbox.isChecked() and self.csv_file_path:
            try:
                with open(self.csv_file_path, 'r', encoding=self.csv_encoding) as file:
                    reader = csv.reader(file)
                    try:
                        next(reader)  # 헤더 행 건너뛰기
                        for row in reader:
                            if len(row) >= 3:
                                url = row[2].strip()
                                if url:
                                    sites.append(url)
                    except StopIteration:
                        pass  # 비어있는 CSV 파일 처리
            except Exception as e:
                self.log_message(f"CSV 파일 읽기 오류: {str(e)}")
                return

        if not sites:
            self.log_message("테스트할 URL이 없습니다.")
            QMessageBox.warning(self, "경고", "테스트할 URL이 없습니다.")
            return

        # 시스템 리소스 확인
        if not check_system_resources():
            reply = QMessageBox.question(
                self, '시스템 리소스 경고',
                "시스템 리소스가 부족합니다. 테스트를 계속하시겠습니까?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            if reply == QMessageBox.No:
                self.log_message("시스템 리소스 부족으로 테스트가 취소되었습니다.")
                return

        # 메모리 정리
        self.manual_memory_cleanup()

        # 기존에 실행 중인 스레드가 있으면 정리
        self.stop_test(silent=True)
        time.sleep(1)  # 기존 스레드 정리 대기

        # 크롬 드라이버와 크롬 프로세스 정리
        kill_all_chrome_drivers()

        # 로그 업데이트
        self.log_message("크롬 드라이버를 정리했습니다.")
        self.log_message(f"테스트 시작: {len(sites)}개 URL, {self.parallel_input.value()}개 스레드")

        # 진행 상황 초기화
        self.progress_bar.setValue(0)

        parallel_count = min(self.parallel_input.value(), 5)  # 최대 5개로 제한
        url_chunks = self.split_urls(sites, parallel_count)

        self.test_threads = []
        for chunk in url_chunks:
            thread = URLTestThread(
                chunk,
                self.interval_input.value(),
                self.count_input.value(),
                self.browser_option_input.currentIndex(),
                self.logging_option_input.currentIndex(),
                self.number_option_input.currentIndex(),
                self.block_phrase_input.text() or "QA/DB_Block_Test",
                self.console_logging_input.currentIndex(),
                self.block_mode_input.currentIndex(),
                self.debug_mode_checkbox.isChecked()
            )
            # 임시 프로필 사용 설정
            thread.use_temp_profile = self.use_temp_profile_checkbox.isChecked()

            thread.log_signal.connect(self.log_message)
            thread.csv_log_signal.connect(self.log_to_csv)
            thread.finished_signal.connect(self.check_all_threads_finished)
            thread.progress_signal.connect(self.update_progress)
            thread.error_signal.connect(self.handle_thread_error)
            thread.start()
            self.test_threads.append(thread)

        self.start_button.setText("종료")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)

        # 버튼 활성화/비활성화 상태 변경
        self.force_stop_button.setEnabled(True)

        # 트레이 아이콘 알림
        if self.tray_icon:
            self.tray_icon.showMessage("URL 테스트 시작", f"{len(sites)}개 URL 테스트가 시작되었습니다.", 3000)

    def handle_thread_error(self, error_message):
        """스레드 오류 처리"""
        self.log_message(f"[{datetime.now()}] 오류 발생: {error_message}")

        if "메모리" in error_message.lower() or "memory" in error_message.lower():
            # 메모리 관련 오류일 경우 자동 정리 시도
            self.log_message("메모리 오류 감지. 자동 정리 시도 중...")
            self.manual_memory_cleanup()

    def update_progress(self, value):
        """진행 상황 업데이트"""
        # 모든 스레드의 진행률 평균을 계산
        if self.test_threads:
            total_progress = 0
            running_threads = 0

            for thread in self.test_threads:
                if thread.isRunning():
                    total_progress += value
                    running_threads += 1

            if running_threads > 0:
                avg_progress = total_progress // running_threads
                self.progress_bar.setValue(avg_progress)
                # UI 즉시 갱신
                QApplication.processEvents()

    def check_all_threads_finished(self):
        """모든 스레드가 완료되었는지 확인"""
        if all(not thread.isRunning() for thread in self.test_threads):
            self.test_finished()

    def stop_test(self, silent=False):
        """테스트 중지"""
        if hasattr(self, 'test_threads') and self.test_threads:
            if not silent:
                self.log_message("테스트 종료 중... 잠시 기다려주세요.")

            # UI 즉시 업데이트
            QApplication.processEvents()

            # 모든 스레드에 종료 신호 전송
            for thread in self.test_threads:
                if thread.isRunning():
                    thread.stop()

            # 스레드가 종료되기를 3초간 대기
            start_time = time.time()
            all_stopped = False

            while not all_stopped and time.time() - start_time < 3:
                all_stopped = True
                for thread in self.test_threads:
                    if thread.isRunning():
                        all_stopped = False
                        QApplication.processEvents()  # UI 이벤트 처리
                time.sleep(0.1)

            # 여전히 실행 중인 스레드 강제 종료
            for thread in self.test_threads:
                if thread.isRunning():
                    thread.terminate()
                    thread.wait(500)  # 0.5초 대기

            # 크롬 드라이버와 크롬 프로세스 강제 종료
            kill_all_chrome_drivers()

            # UI 상태 업데이트
            self.test_threads.clear()
            self.start_button.setText("시작")
            self.start_button.setStyleSheet("""
                QPushButton {
                    background-color: #5a5a5a;
                    color: white;
                }
                QPushButton:hover {
                    background-color: #7a7a7a;
                }
            """)

            if not silent:
                self.log_message("테스트가 중지되었습니다.")

            self.force_stop_button.setEnabled(True)
            self.progress_bar.setValue(0)

            # 트레이 아이콘 알림
            if self.tray_icon and not silent:
                self.tray_icon.showMessage("URL 테스트 종료", "테스트가 중지되었습니다.", 3000)

    def force_stop_test(self):
        """테스트 강제 종료 (모든 크롬 프로세스 포함)"""
        # 사용자에게 작업을 확인
        reply = QMessageBox.question(
            self, '강제 종료 확인',
            "모든 Chrome 및 ChromeDriver 프로세스를 강제 종료합니다. 계속하시겠습니까?",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self.log_message("모든 Chrome 및 ChromeDriver 프로세스 강제 종료 중...")

            # 스레드 강제 종료
            if hasattr(self, 'test_threads') and self.test_threads:
                for thread in self.test_threads:
                    if thread.isRunning():
                        thread.terminate()
                        thread.wait(500)
                self.test_threads.clear()

            # 크롬 드라이버 및 크롬 프로세스 강제 종료
            kill_all_chrome_drivers()
            kill_all_chrome_processes()

            # 상태 업데이트
            self.start_button.setText("시작")
            self.start_button.setStyleSheet("""
                QPushButton {
                    background-color: #5a5a5a;
                    color: white;
                }
                QPushButton:hover {
                    background-color: #7a7a7a;
                }
            """)
            self.progress_bar.setValue(0)
            self.log_message("모든 프로세스가 강제 종료되었습니다.")

            # 메모리 정리
            self.manual_memory_cleanup()

    def test_finished(self):
        """테스트 완료 처리"""
        self.start_button.setText("시작")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
                color: white;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.progress_bar.setValue(100)
        self.log_message("테스트가 완료되었습니다.")
        self.test_threads = []

        # 완료 후 메모리 정리
        self.manual_memory_cleanup()

        # 트레이 아이콘 알림
        if self.tray_icon:
            self.tray_icon.showMessage("URL 테스트 완료", "모든 테스트가 완료되었습니다.", 3000)

    def perform_memory_cleanup(self):
        """주기적인 메모리 정리 작업 - 개선됨"""
        try:
            # 기본 가비지 컬렉션
            gc.collect()

            # 현재 메모리 사용량 확인
            process = psutil.Process(os.getpid())
            memory_info = process.memory_info()
            memory_mb = memory_info.rss / (1024 * 1024)  # MB 단위

            # 메모리 사용량이 500MB 이상인 경우 추가 정리
            if memory_mb > 500:
                logger.info(f"높은 메모리 사용량 감지: {memory_mb:.2f}MB, 추가 정리 수행")

                # Windows에서 메모리 캐시 정리
                if sys.platform == 'win32':
                    try:
                        import ctypes
                        ctypes.windll.kernel32.SetProcessWorkingSetSize(-1, -1)
                    except Exception as e:
                        logger.error(f"메모리 캐시 정리 오류: {str(e)}")

                # 미사용 임시 프로필 정리
                cleanup_temp_profiles()

                # 로그 정리
                cleanup_old_logs()

                # 메모리 정리 후 상태 확인
                memory_after = process.memory_info().rss / (1024 * 1024)
                logger.info(f"메모리 정리 후: {memory_after:.2f}MB (절약: {max(0, memory_mb - memory_after):.2f}MB)")

            # 로그 파일 크기 확인
            if hasattr(self, 'log_filename') and os.path.exists(self.log_filename):
                if os.path.getsize(self.log_filename) > MAX_LOG_SIZE_MB * 1024 * 1024:
                    # 새 로그 파일 생성
                    old_filename = self.log_filename
                    self.log_filename = get_log_filename()
                    self.log_count = 1
                    logger.info(f"로그 파일 크기 제한 초과. 새 파일 생성: {old_filename} → {self.log_filename}")

            # 디스크 공간 확인
            disk = psutil.disk_usage('/')
            if disk.percent > 95:  # 디스크 사용량이 95% 이상이면 긴급 정리
                logger.warning(f"디스크 공간 부족 감지: {disk.percent}%. 긴급 정리 수행")
                # 임시 프로필 디렉토리 완전 정리
                if os.path.exists(CHROME_TEMP_PROFILE_BASE):
                    try:
                        shutil.rmtree(CHROME_TEMP_PROFILE_BASE, ignore_errors=True)
                        os.makedirs(CHROME_TEMP_PROFILE_BASE, exist_ok=True)
                        logger.info("임시 프로필 디렉토리 완전 정리 완료")
                    except Exception as e:
                        logger.error(f"임시 프로필 완전 정리 오류: {str(e)}")

                # 모든 로그 백업 및 정리
                try:
                    log_dir = os.path.join(os.getcwd(), "csv_logs")
                    if os.path.exists(log_dir):
                        backup_dir = os.path.join(os.getcwd(), "csv_logs_backup")
                        os.makedirs(backup_dir, exist_ok=True)

                        # 가장 최근 로그만 보존
                        latest_log = None
                        latest_time = 0

                        for file in os.listdir(log_dir):
                            file_path = os.path.join(log_dir, file)
                            if os.path.isfile(file_path):
                                file_time = os.path.getmtime(file_path)
                                if file_time > latest_time:
                                    latest_time = file_time
                                    latest_log = file

                        # 최신 로그 외에 모든 로그 백업 후 삭제
                        for file in os.listdir(log_dir):
                            if file != latest_log:
                                file_path = os.path.join(log_dir, file)
                                backup_path = os.path.join(backup_dir, file)
                                try:
                                    shutil.copy2(file_path, backup_path)
                                    os.remove(file_path)
                                except Exception as e:
                                    logger.error(f"로그 백업 오류: {str(e)}")

                        logger.info("로그 파일 정리 완료. 최신 로그만 보존됨.")
                except Exception as e:
                    logger.error(f"로그 정리 중 오류: {str(e)}")
        except Exception as e:
            logger.error(f"메모리 정리 중 오류 발생: {str(e)}")

    def process_ui_events(self):
        """UI 이벤트 처리 - 응답성 개선"""
        QApplication.processEvents()

    def on_application_exit(self):
        """애플리케이션 종료 시 정리 작업"""
        # 진행 중인 스레드 종료
        self.stop_test(silent=True)

        # 시스템 모니터 스레드 종료
        if hasattr(self, 'system_monitor') and self.system_monitor:
            self.system_monitor.stop()

        # 크롬 드라이버 및 크롬 프로세스 강제 종료
        kill_all_chrome_drivers()

        # 임시 파일 정리
        cleanup_temp_profiles()

        logger.info("애플리케이션이 정상적으로 종료되었습니다.")

    def closeEvent(self, event):
        """창 닫기 이벤트 처리"""
        # 시스템 트레이 아이콘이 있을 경우
        if self.tray_icon and self.tray_icon.isVisible():
            # 테스트가 실행 중인지 확인
            if self.test_threads and any(thread.isRunning() for thread in self.test_threads):
                reply = QMessageBox.question(
                    self, '최소화 확인',
                    "테스트가 진행 중입니다. 창을 닫는 대신 시스템 트레이로 최소화하시겠습니까?",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes
                )

                if reply == QMessageBox.Yes:
                    self.hide()
                    event.ignore()
                    # 트레이 아이콘 알림
                    self.tray_icon.showMessage(
                        "URL 테스트 계속 실행 중",
                        "애플리케이션이 시스템 트레이에서 계속 실행됩니다.",
                        3000
                    )
                    return

        # 종료 확인
        reply = QMessageBox.question(
            self, '종료 확인',
            "정말로 종료하시겠습니까?",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            # 트레이 아이콘 제거
            if self.tray_icon:
                self.tray_icon.hide()
            # 종료 전 정리 작업
            self.on_application_exit()
            event.accept()
        else:
            event.ignore()


if __name__ == '__main__':
    try:
        # Windows에서 콘솔 창이 닫히지 않게 하기 위한 핸들러 (개선됨)
        if sys.platform == 'win32':
            try:
                kernel32 = ctypes.WinDLL('kernel32')
                handler = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)(lambda event_type: True)
                kernel32.SetConsoleCtrlHandler(handler, True)
                logger.info("콘솔 컨트롤 핸들러가 등록되었습니다.")
            except Exception as e:
                logger.warning(f"콘솔 컨트롤 핸들러 등록 실패: {str(e)}")

        # 시스템 정보 로깅
        logger.info(f"시스템: {sys.platform}, Python: {sys.version}")
        logger.info(f"CPU 코어: {os.cpu_count()}, 메모리: {psutil.virtual_memory().total / (1024 * 1024 * 1024):.2f} GB")

        # 프로그램 시작 시 크롬 드라이버 정리
        kill_all_chrome_drivers()

        # 시작 시 임시 디렉토리 정리
        cleanup_temp_profiles()

        # 시작 시 로그 정리
        cleanup_old_logs()

        app = QApplication(sys.argv)
        ex = URLTestApp()
        ex.show()
        sys.exit(app.exec_())
    except Exception as e:
        logger.critical(f"애플리케이션 실행 중 치명적 오류: {str(e)}")
        # 강제 종료 전 크롬 드라이버 정리
        kill_all_chrome_drivers()
