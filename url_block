import sys
import os
import requests
import time
import logging
import csv
from urllib.parse import urlparse, unquote
from datetime import datetime
import signal
import psutil
import atexit

# Windows 전용 모듈
import ctypes
from ctypes import wintypes

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QGridLayout, QLabel, QLineEdit, QPushButton, QSpinBox, \
    QComboBox, QTextEdit, QHBoxLayout, QFileDialog, QCheckBox, QMessageBox, QProgressBar
from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QMutex, QWaitCondition
from PyQt5.QtGui import QColor, QPalette
import urllib3
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException, NoSuchWindowException

# 로깅 설정
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# InsecureRequestWarning 경고를 무시합니다.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Windows API 상수
TH32CS_SNAPPROCESS = 0x00000002
PROCESS_TERMINATE = 0x0001
INVALID_HANDLE_VALUE = -1

# Windows API 구조체
class PROCESSENTRY32(ctypes.Structure):
    _fields_ = [
        ("dwSize", wintypes.DWORD),
        ("cntUsage", wintypes.DWORD),
        ("th32ProcessID", wintypes.DWORD),
        ("th32DefaultHeapID", ctypes.POINTER(wintypes.ULONG)),
        ("th32ModuleID", wintypes.DWORD),
        ("cntThreads", wintypes.DWORD),
        ("th32ParentProcessID", wintypes.DWORD),
        ("pcPriClassBase", wintypes.LONG),
        ("dwFlags", wintypes.DWORD),
        ("szExeFile", wintypes.CHAR * 260)
    ]

# Windows API 함수
kernel32 = ctypes.windll.kernel32
CreateToolhelp32Snapshot = kernel32.CreateToolhelp32Snapshot
Process32First = kernel32.Process32First
Process32Next = kernel32.Process32Next
CloseHandle = kernel32.CloseHandle
OpenProcess = kernel32.OpenProcess
TerminateProcess = kernel32.TerminateProcess

def is_process_running(process_name):
    """프로세스 이름으로 실행 중인지 확인"""
    for proc in psutil.process_iter(['name']):
        try:
            if process_name.lower() in proc.info['name'].lower():
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False

def terminate_process_by_name(process_name):
    """프로세스 이름으로 강제 종료 (Windows 전용)"""
    try:
        h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
        if h_snapshot == INVALID_HANDLE_VALUE:
            return False
        
        pe32 = PROCESSENTRY32()
        pe32.dwSize = ctypes.sizeof(PROCESSENTRY32)
        
        if not Process32First(h_snapshot, ctypes.byref(pe32)):
            CloseHandle(h_snapshot)
            return False
        
        while True:
            if process_name.lower() in str(pe32.szExeFile).lower():
                pid = pe32.th32ProcessID
                h_process = OpenProcess(PROCESS_TERMINATE, False, pid)
                if h_process:
                    try:
                        if TerminateProcess(h_process, 1):
                            logger.info(f"프로세스 종료 성공: {process_name} (PID: {pid})")
                        else:
                            logger.error(f"프로세스 종료 실패: {process_name} (PID: {pid})")
                    finally:
                        CloseHandle(h_process)
            
            if not Process32Next(h_snapshot, ctypes.byref(pe32)):
                break
        
        CloseHandle(h_snapshot)
        return True
    except Exception as e:
        logger.error(f"프로세스 종료 중 오류 발생: {str(e)}")
        return False

def kill_all_chrome_drivers():
    """모든 chromedriver 프로세스 종료"""
    terminate_process_by_name("chromedriver.exe")

def kill_all_chrome_processes():
    """모든 Chrome 프로세스 종료"""
    terminate_process_by_name("chrome.exe")

def set_process_priority_high():
    """현재 프로세스의 우선순위를 높게 설정"""
    try:
        # Windows에서의 높은 우선순위 설정
        p = psutil.Process(os.getpid())
        p.nice(psutil.HIGH_PRIORITY_CLASS)
        logger.info("프로세스 우선순위가 높게 설정되었습니다.")
    except Exception as e:
        logger.error(f"프로세스 우선순위 설정 오류: {str(e)}")

def register_exit_handlers():
    """프로그램 종료 시 실행할 처리기 등록"""
    atexit.register(kill_all_chrome_drivers)

def get_chrome_version():
    """Windows에서 Chrome 버전 확인"""
    try:
        # Windows의 경우 레지스트리에서 크롬 버전 확인
        if sys.platform == 'win32':
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\Google\Chrome\BLBeacon')
            version, _ = winreg.QueryValueEx(key, 'version')
            return version
    except Exception as e:
        logger.error(f"레지스트리에서 Chrome 버전 확인 실패: {str(e)}")
        try:
            # 레지스트리에서 실패할 경우 기본 경로에서 확인 시도
            paths = [
                r'C:\Program Files\Google\Chrome\Application\chrome.exe',
                r'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe',
                os.path.expandvars(r'%LocalAppData%\Google\Chrome\Application\chrome.exe')
            ]

            from win32com.client import Dispatch
            parser = Dispatch('Scripting.FileSystemObject')

            for path in paths:
                if os.path.exists(path):
                    version = parser.GetFileVersion(path)
                    return version
        except Exception as e:
            logger.error(f"파일에서 Chrome 버전 확인 실패: {str(e)}")

    return None

def setup_driver(debug=False):
    """향상된 크롬 드라이버 설정"""
    options = Options()

    try:
        # 1. 크롬 버전 확인
        chrome_version = get_chrome_version()
        if not chrome_version:
            raise Exception("Chrome 버전을 확인할 수 없습니다.")

        logger.info(f"감지된 Chrome 버전: {chrome_version}")
        major_version = chrome_version.split('.')[0]  # 메이저 버전만 추출

        # 2. 크롬드라이버 다운로드 URL 구성
        driver_version = chrome_version  # 크롬 버전과 동일한 드라이버 버전 사용
        base_url = "https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing"
        download_url = f"{base_url}/{chrome_version}/win64/chromedriver-win64.zip"

        chrome_driver_path = os.path.join(os.getcwd(), "chromedriver.exe")

        # 3. 드라이버가 없거나 버전이 다른 경우 다운로드
        if not os.path.exists(chrome_driver_path):
            import urllib.request
            import zipfile

            logger.info(f"ChromeDriver 버전 {driver_version} 다운로드 중")
            zip_path = "chromedriver.zip"

            # 드라이버 zip 파일 다운로드
            urllib.request.urlretrieve(download_url, zip_path)

            # zip 파일 압축 해제
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                for file in zip_ref.namelist():
                    if file.endswith('chromedriver.exe'):
                        zip_ref.extract(file)
                        if os.path.exists('chromedriver-win64/chromedriver.exe'):
                            import shutil
                            shutil.move('chromedriver-win64/chromedriver.exe', 'chromedriver.exe')
                            shutil.rmtree('chromedriver-win64')

            # 임시 파일 삭제
            if os.path.exists(zip_path):
                os.remove(zip_path)

            logger.info("ChromeDriver 다운로드 완료")

        # 4. 옵션 설정
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_argument('--disable-infobars')
        options.add_argument('--start-maximized')
        options.add_argument('--disable-web-security')
        options.add_argument('--allow-running-insecure-content')
        options.add_argument('--log-level=3')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--enable-unsafe-swiftshader')
        options.add_argument('--disable-software-rasterizer')
        options.add_argument('--proxy-bypass-list=*')
        options.add_argument('--ignore-certificate-errors')
        
        # Windows 최적화를 위한 추가 옵션
        options.add_argument('--disable-extensions')
        options.add_argument('--disable-popup-blocking')
        options.add_argument('--disable-default-apps')
        options.add_argument('--disable-notifications')
        options.add_argument('--disable-background-timer-throttling')
        options.add_argument('--disable-backgrounding-occluded-windows')
        options.add_argument('--disable-renderer-backgrounding')
        options.add_argument('--disable-background-networking')
        options.add_argument('--disable-breakpad')
        options.add_argument('--disable-component-update')
        options.add_argument('--disable-domain-reliability')
        options.add_argument('--disable-sync')
        
        # 메모리 사용량 최적화
        options.add_argument('--js-flags="--max_old_space_size=128"')
        
        # 디버그 모드가 아닐 때만 headless 모드 활성화
        if not debug:
            options.add_argument('--headless')
        
        # 5. Service 객체 생성 및 드라이버 초기화
        service = ChromeService(chrome_driver_path)
        driver = webdriver.Chrome(service=service, options=options)
        
        # 페이지 로드 전략 설정 (성능 향상)
        driver.set_page_load_timeout(30)  # 30초 타임아웃
        driver.get("about:blank")
        logger.info("ChromeDriver 초기화 완료")
        return driver

    except Exception as e:
        detailed_error = f"드라이버 설정 실패: {str(e)}\n"
        detailed_error += f"Chrome 옵션: {options.arguments}\n"
        detailed_error += f"시스템: {sys.platform}\n"
        detailed_error += f"Python 버전: {sys.version}"
        logger.error(detailed_error)
        # 기존 드라이버 프로세스 정리
        kill_all_chrome_drivers()
        raise Exception(f"ChromeDriver 초기화 실패: {str(e)}")

def get_url_with_protocol(url):
    """URL에 프로토콜 추가 및 유효성 검사"""
    if not url.strip():  # 빈 URL 체크
        return None, "빈 URL이 제공됨"
    try:
        parsed_url = urlparse(url)
        if parsed_url.scheme:
            return url, None
        else:
            try:
                response = requests.get(f"https://{url}", timeout=5, verify=False)
                response.raise_for_status()
                return f"https://{url}", None
            except requests.exceptions.RequestException:
                return f"http://{url}", None
    except Exception as e:
        error_msg = f"유효하지 않은 URL 또는 IP 주소: {url}. 오류: {str(e)}"
        logger.error(error_msg)
        return None, error_msg


def get_log_filename():
    """로그 파일명 생성"""
    return f"로그_{datetime.now().strftime('%y%m%d%H')}.csv"


class URLTestThread(QThread):
    """URL 테스트 스레드 - 개선된 버전"""
    log_signal = pyqtSignal(str)
    csv_log_signal = pyqtSignal(list)
    finished_signal = pyqtSignal()
    progress_signal = pyqtSignal(int)  # 진행 상황 표시용
    
    def __init__(self, sites, interval, count, browser_option, logging_option, number_option, block_phrase,
                 console_logging_option, block_mode, debug_mode=False):
        super().__init__()
        self.sites = sites
        self.interval = interval
        self.count = count
        self.browser_option = browser_option
        self.logging_option = logging_option
        self.number_option = number_option
        self.block_phrase = block_phrase
        self.console_logging_option = console_logging_option
        self.block_mode = block_mode
        self.debug_mode = debug_mode
        self.running = True
        self.driver = None
        self.mutex = QMutex()
        self.wait_condition = QWaitCondition()
        self.shutdown_event = False
        
        # 스레드 종료 시 자원 정리
        self.finished.connect(self.cleanup_resources)

    def run(self):
        """메인 스레드 실행 함수"""
        iteration = 0
        self.driver = None
        sites_count = len(self.sites)
        
        try:
            while self.running and (self.count == 0 or iteration < self.count):
                for site_idx, site in enumerate(self.sites):
                    if not self.running:
                        break
                        
                    # 진행 상황 보고
                    progress = int((site_idx / sites_count) * 100)
                    self.progress_signal.emit(progress)
                    
                    site_with_protocol, error_msg = get_url_with_protocol(site)
                    if error_msg:
                        self.log_signal.emit(f"[{datetime.now()}] 오류: {error_msg}")
                        self.csv_log_signal.emit([site, "오류", error_msg])
                        continue

                    # 브라우저가 실행 중인지 확인하고, 종료되었다면 재시작
                    if self.browser_option == 1:  # 한 번만 열기 옵션일 때
                        try:
                            if self.driver is not None:
                                # 브라우저가 살아있는지 테스트
                                self.driver.current_url
                        except (WebDriverException, NoSuchWindowException, Exception) as e:
                            self.log_signal.emit(f"[{datetime.now()}] 브라우저가 종료됨, 재시작 시도")
                            try:
                                self.safe_quit_driver()
                            except:
                                pass
                            self.driver = None
                            time.sleep(1)  # 재시작 전 잠시 대기

                    # 브라우저가 없으면 새로 시작
                    if self.browser_option == 0 or self.driver is None:
                        try:
                            self.driver = setup_driver(debug=self.debug_mode)
                        except Exception as e:
                            self.log_signal.emit(f"[{datetime.now()}] 드라이버 설정 오류: {str(e)}")
                            time.sleep(2)  # 오류 발생 시 더 길게 대기
                            continue

                    if self.number_option == 1:
                        url = f"{site_with_protocol}/{iteration + 1}"
                    else:
                        url = site_with_protocol

                    try:
                        self.driver.set_page_load_timeout(30)  # 페이지 로드 타임아웃 설정
                        self.driver.get(url)

                        # 페이지 로드 완료 대기
                        WebDriverWait(self.driver, 30).until(
                            EC.presence_of_element_located((By.TAG_NAME, "body"))
                        )

                        # 스레드 안전한 대기
                        self.safe_sleep(self.interval)
                        
                        if not self.running:
                            break

                        if self.block_mode == 0:  # 인라인 모드
                            iframes = self.driver.find_elements(By.TAG_NAME, "iframe")
                            if len(iframes) > 0:
                                iframe_src = iframes[0].get_attribute('src')
                                decoded_src = unquote(iframe_src) if iframe_src else ""
                                if self.block_phrase in decoded_src:
                                    log_message = f"[{datetime.now()}] URL: {url} - 차단됨 (인라인)"
                                    if self.console_logging_option == 0 or self.console_logging_option == 3:
                                        self.log_signal.emit(log_message)
                                    # 차단된 경우만 또는 모두 로그일 때만 CSV 로깅
                                    if self.console_logging_option == 0 or self.console_logging_option == 3:
                                        self.csv_log_signal.emit([url, "차단됨 (인라인)", ""])
                                else:
                                    log_message = f"[{datetime.now()}] URL: {url} - 차단되지 않음 (인라인)"
                                    if self.console_logging_option == 1 or self.console_logging_option == 3:
                                        self.log_signal.emit(log_message)
                                    # 차단되지 않은 경우만 또는 모두 로그일 때만 CSV 로깅
                                    if self.console_logging_option == 1 or self.console_logging_option == 3:
                                        self.csv_log_signal.emit([url, "차단되지 않음 (인라인)", ""])
                            else:
                                log_message = f"[{datetime.now()}] URL: {url} - 차단되지 않음 (인라인)"
                                if self.console_logging_option == 1 or self.console_logging_option == 3:
                                    self.log_signal.emit(log_message)
                                # 차단되지 않은 경우만 또는 모두 로그일 때만 CSV 로깅
                                if self.console_logging_option == 1 or self.console_logging_option == 3:
                                    self.csv_log_signal.emit([url, "차단되지 않음 (인라인)", ""])

                    except TimeoutException:
                        log_message = f"[{datetime.now()}] URL: {url} - 30초 동안 로딩 없음"
                        self.log_signal.emit(log_message)
                        self.csv_log_signal.emit([url, "30초 동안 로딩 없음", ""])
                        continue  # 다음 URL로 넘어감

                    except Exception as e:
                        if self.block_mode == 0:
                            log_message = f"[{datetime.now()}] URL: {url} - 접속 안됨 (인라인) - {str(e)}"
                            self.csv_log_signal.emit([url, "접속 안됨 (인라인)", str(e)])
                        else:
                            log_message = f"[{datetime.now()}] URL: {url} - 접속 안됨 (미러링) - {str(e)}"
                            self.csv_log_signal.emit([url, "접속 안됨 (미러링)", str(e)])

                        self.log_signal.emit(log_message)

                        if self.browser_option == 0:
                            self.safe_quit_driver()
                            self.driver = None

                    if self.browser_option == 0:
                        self.safe_quit_driver()
                        self.driver = None

                if not self.running:
                    break
                    
                iteration += 1
                
                # 진행 상황 100% 표시
                if iteration >= self.count and self.count > 0:
                    self.progress_signal.emit(100)

        except Exception as e:
            logger.error(f"스레드 실행 중 예외 발생: {str(e)}")
        finally:
            self.safe_quit_driver()
            self.finished_signal.emit()

    def safe_sleep(self, seconds):
        """스레드 안전한 대기 (중단 가능)"""
        if seconds <= 0:
            return
            
        self.mutex.lock()
        try:
            if self.running:
                self.wait_condition.wait(self.mutex, seconds * 1000)
        finally:
            self.mutex.unlock()
    
    def safe_quit_driver(self):
        """안전하게 드라이버 종료"""
        if self.driver is not None:
            try:
                self.driver.quit()
            except Exception as e:
                logger.error(f"드라이버 종료 실패: {str(e)}")
            finally:
                self.driver = None

    def stop(self):
        """스레드 중지 (더 빠르고 안정적으로)"""
        self.running = False
        
        # 대기 중인 스레드 깨우기
        self.mutex.lock()
        self.wait_condition.wakeAll()
        self.mutex.unlock()
        
        # 드라이버 안전하게 종료
        self.safe_quit_driver()
        
        # 크롬 드라이버 프로세스 강제 종료
        kill_all_chrome_drivers()
        
        # QThread 종료
        self.quit()
        if not self.wait(3000):  # 3초 대기
            logger.warning("스레드가 정상적으로 종료되지 않아 강제 종료합니다.")
            self.terminate()
            self.wait(1000)
    
    def cleanup_resources(self):
        """스레드 종료 시 자원 정리"""
        logger.info("스레드 자원 정리 중...")
        self.safe_quit_driver()


class URLTestApp(QWidget):
    """URL 테스트 애플리케이션 - 개선된 버전"""
    def __init__(self):
        super().__init__()
        self.initUI()
        self.log_filename = get_log_filename()
        self.log_count = 1
        self.test_threads = []
        self.csv_file_path = None
        
        # 윈도우 최적화 설정
        set_process_priority_high()
        register_exit_handlers()
        
        # 정기적으로 메모리 관리 수행
        self.cleanup_timer = QTimer(self)
        self.cleanup_timer.timeout.connect(self.perform_memory_cleanup)
        self.cleanup_timer.start(30000)  # 30초마다 실행
        
        # 프로그램 종료 시 정리 작업
        QApplication.instance().aboutToQuit.connect(self.on_application_exit)

    def split_urls(self, urls, chunks):
        """URLs를 지정된 chunks 수만큼 분할"""
        n = len(urls)
        if n == 0:
            return []
        if chunks > n:
            chunks = n
        size = n // chunks
        remainder = n % chunks
        result = []
        start = 0
        for i in range(chunks):
            end = start + size + (1 if i < remainder else 0)
            result.append(urls[start:end])
            start = end
        return result

    def initUI(self):
        """UI 초기화"""
        self.setWindowTitle('URL 테스트 애플리케이션')
        self.setGeometry(100, 100, 800, 600)
        self.setStyleSheet("""
            QWidget {
                background-color: #2e2e2e;
                color: white;
            }
            QLabel {
                font-size: 14px;
                font-family: Arial, sans-serif;
            }
            QLineEdit, QSpinBox, QComboBox {
                font-size: 14px;
                font-family: Arial, sans-serif;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 5px;
                background-color: #444;
                color: white;
            }
            QPushButton {
                font-size: 14px;
                font-family: Arial, sans-serif;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 5px;
                color: white;
            }
            QTextEdit {
                font-size: 14px;
                font-family: Arial, sans-serif;
                background-color: #1e1e1e;
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                padding: 10px;
                color: white;
            }
            QProgressBar {
                border: 1px solid #3a3a3a;
                border-radius: 5px;
                background-color: #444;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                width: 10px;
                margin: 0.5px;
            }
        """)

        layout = QVBoxLayout()
        form_layout = QGridLayout()
        form_layout.setSpacing(10)  # 입력 필드 간의 간격 설정

        self.site_checkbox = QCheckBox("사이트")
        self.site_checkbox.setChecked(True)
        self.site_input = QLineEdit()
        self.site_input.setPlaceholderText("예: example1.com,example2.com,example3.com")
        self.site_input.setText("soosantest.com")

        self.csv_checkbox = QCheckBox("CSV 파일")
        self.csv_file_input = QLineEdit()
        self.csv_file_input.setReadOnly(True)
        self.csv_file_button = QPushButton("파일 선택")
        self.csv_file_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.csv_file_button.clicked.connect(self.select_csv_file)

        self.interval_label = QLabel("간격 (초):")
        self.interval_input = QSpinBox()
        self.interval_input.setValue(1)
        self.interval_input.setToolTip("각 테스트 사이의 시간 간격을 설정합니다.")

        self.count_label = QLabel("반복 횟수 (0은 무한 반복):")
        self.count_input = QSpinBox()
        self.count_input.setRange(0, 65535)
        self.count_input.setValue(1)
        self.count_input.setToolTip("테스트를 반복할 횟수를 설정합니다. 0으로 설정하면 무한 반복됩니다.")

        self.browser_option_label = QLabel("브라우저 옵션:")
        self.browser_option_input = QComboBox()
        self.browser_option_input.addItems(["매번 열고 닫기", "한 번만 열기"])
        self.browser_option_input.setToolTip("각 테스트마다 브라우저를 열고 닫을지, 한 번만 열고 계속 사용할지 선택합니다.")

        self.logging_option_label = QLabel("로그 옵션:")
        self.logging_option_input = QComboBox()
        self.logging_option_input.addItems(["로그 비활성화", "로그 활성화"])
        self.logging_option_input.setToolTip("테스트 결과를 로그 파일에 기록할지 선택합니다.")

        self.number_option_label = QLabel("숫자 옵션:")
        self.number_option_input = QComboBox()
        self.number_option_input.addItems(["사용 안 함", "사용"])
        self.number_option_input.setToolTip("각 테스트 반복 시 URL 경로에 숫자를 추가할지 선택합니다.")

        self.block_phrase_label = QLabel("차단 문구:")
        self.block_phrase_input = QLineEdit()
        self.block_phrase_input.setPlaceholderText("예: QA/DB_Block_Test")
        self.block_phrase_input.setText("QA/DB_Block_Test")
        self.block_phrase_input.setToolTip("iframe URL에 차단 여부를 확인할 문구를 입력합니다.")

        self.console_logging_label = QLabel("콘솔 로그 옵션:")
        self.console_logging_input = QComboBox()
        self.console_logging_input.addItems(["차단된 경우만", "차단되지 않은 경우만", "로그 없음", "모두 로그"])
        self.console_logging_input.setToolTip("콘솔에 어떤 로그를 표시할지 선택합니다.")

        self.block_mode_label = QLabel("차단 확인 모드:")
        self.block_mode_input = QComboBox()
        self.block_mode_input.addItems(["인라인", "미러링"])
        self.block_mode_input.setToolTip("차단 확인 모드를 선택합니다.")

        # 브라우저 병렬 처리 옵션
        self.parallel_label = QLabel("병렬 처리 개수:")
        self.parallel_input = QSpinBox()
        self.parallel_input.setRange(1, 5)  # 최대 5개 쓰레드로 제한 (윈도우 성능 고려)
        self.parallel_input.setValue(1)
        self.parallel_input.setToolTip("동시에 실행할 브라우저 개수를 설정합니다.")
        
        # 디버그 모드 옵션 추가
        self.debug_mode_checkbox = QCheckBox("디버그 모드 (브라우저 표시)")
        self.debug_mode_checkbox.setChecked(False)
        self.debug_mode_checkbox.setToolTip("체크하면 브라우저가 화면에 표시됩니다. 테스트 디버깅용.")

        # 프로그레스 바 추가
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("%p%")

        self.start_button = QPushButton("시작")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.start_button.clicked.connect(self.toggle_test)

        self.clear_button = QPushButton("로그 지우기")
        self.clear_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.clear_button.clicked.connect(self.clear_log)
        
        # 강제 종료 버튼 추가
        self.force_stop_button = QPushButton("강제 종료")
        self.force_stop_button.setStyleSheet("""
            QPushButton {
                background-color: #d32f2f;
                color: white;
            }
            QPushButton:hover {
                background-color: #b71c1c;
            }
        """)
        self.force_stop_button.clicked.connect(self.force_stop_test)
        self.force_stop_button.setToolTip("모든 Chrome 및 ChromeDriver 프로세스를 강제 종료합니다.")

        self.output = QTextEdit()
        self.output.setReadOnly(True)

        # UI 요소의 최소 너비 설정
        min_width = 300
        self.site_input.setMinimumWidth(min_width)
        self.csv_file_input.setMinimumWidth(min_width)
        self.interval_input.setMinimumWidth(min_width)
        self.count_input.setMinimumWidth(min_width)
        self.browser_option_input.setMinimumWidth(min_width)
        self.logging_option_input.setMinimumWidth(min_width)
        self.number_option_input.setMinimumWidth(min_width)
        self.block_phrase_input.setMinimumWidth(min_width)
        self.console_logging_input.setMinimumWidth(min_width)
        self.block_mode_input.setMinimumWidth(min_width)

        form_layout.addWidget(self.site_checkbox, 0, 0)
        form_layout.addWidget(self.site_input, 0, 1, 1, 3)
        form_layout.addWidget(self.csv_checkbox, 1, 0)
        form_layout.addWidget(self.csv_file_input, 1, 1, 1, 2)
        form_layout.addWidget(self.csv_file_button, 1, 3)
        form_layout.addWidget(self.interval_label, 2, 0)
        form_layout.addWidget(self.interval_input, 2, 1, 1, 3)
        form_layout.addWidget(self.count_label, 3, 0)
        form_layout.addWidget(self.count_input, 3, 1, 1, 3)
        form_layout.addWidget(self.browser_option_label, 4, 0)
        form_layout.addWidget(self.browser_option_input, 4, 1, 1, 3)
        form_layout.addWidget(self.logging_option_label, 5, 0)
        form_layout.addWidget(self.logging_option_input, 5, 1, 1, 3)
        form_layout.addWidget(self.number_option_label, 6, 0)
        form_layout.addWidget(self.number_option_input, 6, 1, 1, 3)
        form_layout.addWidget(self.block_phrase_label, 7, 0)
        form_layout.addWidget(self.block_phrase_input, 7, 1, 1, 3)
        form_layout.addWidget(self.console_logging_label, 8, 0)
        form_layout.addWidget(self.console_logging_input, 8, 1, 1, 3)
        form_layout.addWidget(self.block_mode_label, 9, 0)
        form_layout.addWidget(self.block_mode_input, 9, 1, 1, 3)
        form_layout.addWidget(self.parallel_label, 10, 0)
        form_layout.addWidget(self.parallel_input, 10, 1, 1, 3)
        form_layout.addWidget(self.debug_mode_checkbox, 11, 0, 1, 4)
        form_layout.addWidget(self.progress_bar, 12, 0, 1, 4)

        button_layout = QHBoxLayout()
        button_layout.addWidget(self.start_button)
        button_layout.addWidget(self.clear_button)
        button_layout.addWidget(self.force_stop_button)

        layout.addLayout(form_layout)
        layout.addLayout(button_layout)
        layout.addWidget(self.output)
        self.setLayout(layout)

    def select_csv_file(self):
        """CSV 파일 선택"""
        try:
            file_dialog = QFileDialog()
            file_path, _ = file_dialog.getOpenFileName(self, "CSV 파일 선택", "", "CSV Files (*.csv)")
            if file_path:
                # CSV 파일 유효성 검증 추가
                with open(file_path, 'r', encoding='utf-8-sig') as f:
                    reader = csv.reader(f)
                    next(reader)  # 헤더 확인
                self.csv_file_path = file_path
                self.csv_file_input.setText(file_path)
        except UnicodeDecodeError:
            # UTF-8 디코딩 실패 시 cp949로 시도
            try:
                with open(file_path, 'r', encoding='cp949') as f:
                    reader = csv.reader(f)
                    next(reader)  # 헤더 확인
                self.csv_file_path = file_path
                self.csv_file_input.setText(file_path)
            except Exception as e:
                self.log_message(f"CSV 파일 로드 오류: {str(e)}")
                QMessageBox.critical(self, "오류", f"CSV 파일을 읽을 수 없습니다: {str(e)}")
        except Exception as e:
            self.log_message(f"CSV 파일 로드 오류: {str(e)}")
            QMessageBox.critical(self, "오류", f"CSV 파일을 읽을 수 없습니다: {str(e)}")

    def log_message(self, message):
        """UI에 로그 메시지 추가"""
        self.output.append(message)
        # 자동 스크롤
        self.output.verticalScrollBar().setValue(self.output.verticalScrollBar().maximum())
        # 즉시 UI 업데이트
        QApplication.processEvents()

    def clear_log(self):
        """로그 창 지우기"""
        self.output.clear()

    def log_to_csv(self, log_data):
        """CSV 파일에 로그 기록"""
        try:
            if self.logging_option_input.currentIndex() == 1:  # 로그 활성화
                with open(self.log_filename, 'a', newline='', encoding='utf-8') as file:
                    writer = csv.writer(file)
                    writer.writerow([self.log_count] + log_data)
                self.log_count += 1
        except Exception as e:
            logger.error(f"CSV 로깅 오류: {str(e)}")
            # 최신 로그 파일을 다시 생성
            self.log_filename = get_log_filename()

    def toggle_test(self):
        """테스트 시작/중지 토글"""
        if not self.test_threads or all(not thread.isRunning() for thread in self.test_threads):
            self.start_test()
        else:
            self.stop_test()

    def start_test(self):
        """테스트 시작"""
        sites = []
        if self.site_checkbox.isChecked():
            sites = [site.strip() for site in self.site_input.text().split(",") if site.strip()]

        # CSV 파일에서 URL 정보 읽어오기
        if self.csv_checkbox.isChecked() and self.csv_file_path:
            try:
                with open(self.csv_file_path, 'r', encoding='utf-8-sig') as file:
                    reader = csv.reader(file)
                    try:
                        next(reader)  # 헤더 행 건너뛰기
                        for row in reader:
                            if len(row) >= 3:
                                url = row[2].strip()
                                if url:
                                    sites.append(url)
                    except StopIteration:
                        pass  # 비어있는 CSV 파일 처리
            except UnicodeDecodeError:
                # UTF-8 디코딩 실패 시 cp949로 시도
                try:
                    with open(self.csv_file_path, 'r', encoding='cp949') as file:
                        reader = csv.reader(file)
                        try:
                            next(reader)  # 헤더 행 건너뛰기
                            for row in reader:
                                if len(row) >= 3:
                                    url = row[2].strip()
                                    if url:
                                        sites.append(url)
                        except StopIteration:
                            pass  # 비어있는 CSV 파일 처리
                except Exception as e:
                    self.log_message(f"CSV 파일 읽기 오류: {str(e)}")
                    return
            except Exception as e:
                self.log_message(f"CSV 파일 읽기 오류: {str(e)}")
                return

        if not sites:
            self.log_message("테스트할 URL이 없습니다.")
            QMessageBox.warning(self, "경고", "테스트할 URL이 없습니다.")
            return

        # 기존에 실행 중인 스레드가 있으면 정리
        self.stop_test(silent=True)
        time.sleep(1)  # 기존 스레드 정리 대기
        
        # 크롬 드라이버와 크롬 프로세스 정리
        kill_all_chrome_drivers()
        
        # 로그 업데이트
        self.log_message("크롬 드라이버를 정리했습니다.")
        self.log_message(f"테스트 시작: {len(sites)}개 URL, {self.parallel_input.value()}개 스레드")
        
        # 진행 상황 초기화
        self.progress_bar.setValue(0)

        parallel_count = min(self.parallel_input.value(), 5)  # 최대 5개로 제한
        url_chunks = self.split_urls(sites, parallel_count)

        self.test_threads = []
        for chunk in url_chunks:
            thread = URLTestThread(
                chunk,
                self.interval_input.value(),
                self.count_input.value(),
                self.browser_option_input.currentIndex(),
                self.logging_option_input.currentIndex(),
                self.number_option_input.currentIndex(),
                self.block_phrase_input.text() or "QA/DB_Block_Test",
                self.console_logging_input.currentIndex(),
                self.block_mode_input.currentIndex(),
                self.debug_mode_checkbox.isChecked()
            )
            thread.log_signal.connect(self.log_message)
            thread.csv_log_signal.connect(self.log_to_csv)
            thread.finished_signal.connect(self.check_all_threads_finished)
            thread.progress_signal.connect(self.update_progress)
            thread.start()
            self.test_threads.append(thread)

        self.start_button.setText("종료")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        
        # 버튼 활성화/비활성화 상태 변경
        self.force_stop_button.setEnabled(True)

    def update_progress(self, value):
        """진행 상황 업데이트"""
        # 모든 스레드의 진행률 평균을 계산
        if self.test_threads:
            total_progress = 0
            running_threads = 0
            
            for thread in self.test_threads:
                if thread.isRunning():
                    total_progress += value
                    running_threads += 1
            
            if running_threads > 0:
                avg_progress = total_progress // running_threads
                self.progress_bar.setValue(avg_progress)
                # UI 즉시 갱신
                QApplication.processEvents()

    def check_all_threads_finished(self):
        """모든 스레드가 완료되었는지 확인"""
        if all(not thread.isRunning() for thread in self.test_threads):
            self.test_finished()

    def stop_test(self, silent=False):
        """테스트 중지"""
        if hasattr(self, 'test_threads') and self.test_threads:
            if not silent:
                self.log_message("테스트 종료 중... 잠시 기다려주세요.")

            # UI 즉시 업데이트
            QApplication.processEvents()
            
            # 모든 스레드에 종료 신호 전송
            for thread in self.test_threads:
                if thread.isRunning():
                    thread.stop()
            
            # 스레드가 종료되기를 3초간 대기
            start_time = time.time()
            all_stopped = False
            
            while not all_stopped and time.time() - start_time < 3:
                all_stopped = True
                for thread in self.test_threads:
                    if thread.isRunning():
                        all_stopped = False
                        QApplication.processEvents()  # UI 이벤트 처리
                time.sleep(0.1)
            
            # 여전히 실행 중인 스레드 강제 종료
            for thread in self.test_threads:
                if thread.isRunning():
                    thread.terminate()
                    thread.wait(500)  # 0.5초 대기
            
            # 크롬 드라이버와 크롬 프로세스 강제 종료
            kill_all_chrome_drivers()
            
            # UI 상태 업데이트
            self.test_threads.clear()
            self.start_button.setText("시작")
            self.start_button.setStyleSheet("""
                QPushButton {
                    background-color: #5a5a5a;
                    color: white;
                }
                QPushButton:hover {
                    background-color: #7a7a7a;
                }
            """)
            
            if not silent:
                self.log_message("테스트가 중지되었습니다.")
                
            self.force_stop_button.setEnabled(True)
            self.progress_bar.setValue(0)

    def force_stop_test(self):
        """테스트 강제 종료 (모든 크롬 프로세스 포함)"""
        # 사용자에게 작업을 확인
        reply = QMessageBox.question(
            self, '강제 종료 확인', 
            "모든 Chrome 및 ChromeDriver 프로세스를 강제 종료합니다. 계속하시겠습니까?",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.log_message("모든 Chrome 및 ChromeDriver 프로세스 강제 종료 중...")
            
            # 스레드 강제 종료
            if hasattr(self, 'test_threads') and self.test_threads:
                for thread in self.test_threads:
                    if thread.isRunning():
                        thread.terminate()
                        thread.wait(500)
                self.test_threads.clear()
            
            # 크롬 드라이버 및 크롬 프로세스 강제 종료
            kill_all_chrome_drivers()
            kill_all_chrome_processes()
            
            # 상태 업데이트
            self.start_button.setText("시작")
            self.start_button.setStyleSheet("""
                QPushButton {
                    background-color: #5a5a5a;
                    color: white;
                }
                QPushButton:hover {
                    background-color: #7a7a7a;
                }
            """)
            self.progress_bar.setValue(0)
            self.log_message("모든 프로세스가 강제 종료되었습니다.")

    def test_finished(self):
        """테스트 완료 처리"""
        self.start_button.setText("시작")
        self.start_button.setStyleSheet("""
            QPushButton {
                background-color: #5a5a5a;
                color: white;
            }
            QPushButton:hover {
                background-color: #7a7a7a;
            }
        """)
        self.progress_bar.setValue(100)
        self.log_message("테스트가 완료되었습니다.")
        self.test_threads = []
    
    def perform_memory_cleanup(self):
        """주기적인 메모리 정리 작업"""
        import gc
        gc.collect()
    
    def on_application_exit(self):
        """애플리케이션 종료 시 정리 작업"""
        # 진행 중인 스레드 종료
        self.stop_test(silent=True)
        
        # 크롬 드라이버 및 크롬 프로세스 강제 종료
        kill_all_chrome_drivers()
        
        logger.info("애플리케이션이 정상적으로 종료되었습니다.")


if __name__ == '__main__':
    try:
        # Windows에서 콘솔 창이 닫히지 않게 하기 위한 핸들러
        kernel32 = ctypes.WinDLL('kernel32')
        kernel32.SetConsoleCtrlHandler(lambda event_type: True, True)
        
        # 프로그램 시작 시 크롬 드라이버 정리
        kill_all_chrome_drivers()
        
        app = QApplication(sys.argv)
        ex = URLTestApp()
        ex.show()
        sys.exit(app.exec_())
    except Exception as e:
        logger.critical(f"애플리케이션 실행 중 치명적 오류: {str(e)}")
        # 강제 종료 전 크롬 드라이버 정리
        kill_all_chrome_drivers()
